"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@paper-design";
exports.ids = ["vendor-chunks/@paper-design"];
exports.modules = {

/***/ "(ssr)/./node_modules/@paper-design/shaders-react/dist/color-props-are-equal.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@paper-design/shaders-react/dist/color-props-are-equal.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   colorPropsAreEqual: () => (/* binding */ colorPropsAreEqual)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nfunction colorPropsAreEqual(prevProps, nextProps) {\n  for (const key in prevProps) {\n    if (key === \"colors\") {\n      const prevIsArray = Array.isArray(prevProps.colors);\n      const nextIsArray = Array.isArray(nextProps.colors);\n      if (!prevIsArray || !nextIsArray) {\n        if (Object.is(prevProps.colors, nextProps.colors) === false) {\n          return false;\n        }\n        continue;\n      }\n      if (prevProps.colors?.length !== nextProps.colors?.length) {\n        return false;\n      }\n      if (!prevProps.colors?.every((color, index) => color === nextProps.colors?.[index])) {\n        return false;\n      }\n      continue;\n    }\n    if (Object.is(prevProps[key], nextProps[key]) === false) {\n      return false;\n    }\n  }\n  return true;\n}\n\n//# sourceMappingURL=color-props-are-equal.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3QvY29sb3ItcHJvcHMtYXJlLWVxdWFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcnR0aWNmb3gvRGVza3RvcC9Xb3JrL3Bob3RvYXBwL25vZGVfbW9kdWxlcy9AcGFwZXItZGVzaWduL3NoYWRlcnMtcmVhY3QvZGlzdC9jb2xvci1wcm9wcy1hcmUtZXF1YWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqICAgICAgICAgICAgICAgICAgICBQYXBlciBTaGFkZXJzICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICBodHRwczovL2dpdGh1Yi5jb20vcGFwZXItZGVzaWduL3NoYWRlcnMgICAgICAgKlxuICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICovXG5cbmZ1bmN0aW9uIGNvbG9yUHJvcHNBcmVFcXVhbChwcmV2UHJvcHMsIG5leHRQcm9wcykge1xuICBmb3IgKGNvbnN0IGtleSBpbiBwcmV2UHJvcHMpIHtcbiAgICBpZiAoa2V5ID09PSBcImNvbG9yc1wiKSB7XG4gICAgICBjb25zdCBwcmV2SXNBcnJheSA9IEFycmF5LmlzQXJyYXkocHJldlByb3BzLmNvbG9ycyk7XG4gICAgICBjb25zdCBuZXh0SXNBcnJheSA9IEFycmF5LmlzQXJyYXkobmV4dFByb3BzLmNvbG9ycyk7XG4gICAgICBpZiAoIXByZXZJc0FycmF5IHx8ICFuZXh0SXNBcnJheSkge1xuICAgICAgICBpZiAoT2JqZWN0LmlzKHByZXZQcm9wcy5jb2xvcnMsIG5leHRQcm9wcy5jb2xvcnMpID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmV2UHJvcHMuY29sb3JzPy5sZW5ndGggIT09IG5leHRQcm9wcy5jb2xvcnM/Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXByZXZQcm9wcy5jb2xvcnM/LmV2ZXJ5KChjb2xvciwgaW5kZXgpID0+IGNvbG9yID09PSBuZXh0UHJvcHMuY29sb3JzPy5baW5kZXhdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5pcyhwcmV2UHJvcHNba2V5XSwgbmV4dFByb3BzW2tleV0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCB7XG4gIGNvbG9yUHJvcHNBcmVFcXVhbFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbG9yLXByb3BzLWFyZS1lcXVhbC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders-react/dist/color-props-are-equal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders-react/dist/shader-mount.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@paper-design/shaders-react/dist/shader-mount.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShaderMount: () => (/* binding */ ShaderMount)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @paper-design/shaders */ \"(ssr)/./node_modules/@paper-design/shaders/dist/get-empty-pixel.js\");\n/* harmony import */ var _paper_design_shaders__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @paper-design/shaders */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shader-mount.js\");\n/* harmony import */ var _use_merge_refs_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./use-merge-refs.js */ \"(ssr)/./node_modules/@paper-design/shaders-react/dist/use-merge-refs.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */ /* __next_internal_client_entry_do_not_use__ ShaderMount auto */ \n\n\n\nasync function processUniforms(uniformsProp) {\n    const processedUniforms = {};\n    const imageLoadPromises = [];\n    const isValidUrl = (url)=>{\n        try {\n            if (url.startsWith(\"/\")) return true;\n            new URL(url);\n            return true;\n        } catch  {\n            return false;\n        }\n    };\n    const isExternalUrl = (url)=>{\n        try {\n            if (url.startsWith(\"/\")) return false;\n            const urlObject = new URL(url, window.location.origin);\n            return urlObject.origin !== window.location.origin;\n        } catch  {\n            return false;\n        }\n    };\n    Object.entries(uniformsProp).forEach(([key, value])=>{\n        if (typeof value === \"string\") {\n            if (!value) {\n                processedUniforms[key] = (0,_paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.getEmptyPixel)();\n                return;\n            }\n            if (!isValidUrl(value)) {\n                console.warn(`Uniform \"${key}\" has invalid URL \"${value}\". Skipping image loading.`);\n                return;\n            }\n            const imagePromise = new Promise((resolve, reject)=>{\n                const img = new Image();\n                if (isExternalUrl(value)) {\n                    img.crossOrigin = \"anonymous\";\n                }\n                img.onload = ()=>{\n                    processedUniforms[key] = img;\n                    resolve();\n                };\n                img.onerror = ()=>{\n                    console.error(`Could not set uniforms. Failed to load image at ${value}`);\n                    reject();\n                };\n                img.src = value;\n            });\n            imageLoadPromises.push(imagePromise);\n        } else {\n            processedUniforms[key] = value;\n        }\n    });\n    await Promise.all(imageLoadPromises);\n    return processedUniforms;\n}\nconst ShaderMount = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function ShaderMountImpl({ fragmentShader, uniforms: uniformsProp, webGlContextAttributes, speed = 0, frame = 0, width, height, minPixelRatio, maxPixelCount, style, ...divProps }, forwardedRef) {\n    const [isInitialized, setIsInitialized] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const divRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const shaderMountRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const webGlContextAttributesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(webGlContextAttributes);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"ShaderMount.ShaderMountImpl.useEffect\": ()=>{\n            const initShader = {\n                \"ShaderMount.ShaderMountImpl.useEffect.initShader\": async ()=>{\n                    const uniforms = await processUniforms(uniformsProp);\n                    if (divRef.current && !shaderMountRef.current) {\n                        shaderMountRef.current = new _paper_design_shaders__WEBPACK_IMPORTED_MODULE_3__.ShaderMount(divRef.current, fragmentShader, uniforms, webGlContextAttributesRef.current, speed, frame, minPixelRatio, maxPixelCount);\n                        setIsInitialized(true);\n                    }\n                }\n            }[\"ShaderMount.ShaderMountImpl.useEffect.initShader\"];\n            initShader();\n            return ({\n                \"ShaderMount.ShaderMountImpl.useEffect\": ()=>{\n                    shaderMountRef.current?.dispose();\n                    shaderMountRef.current = null;\n                }\n            })[\"ShaderMount.ShaderMountImpl.useEffect\"];\n        }\n    }[\"ShaderMount.ShaderMountImpl.useEffect\"], [\n        fragmentShader\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"ShaderMount.ShaderMountImpl.useEffect\": ()=>{\n            let isStale = false;\n            const updateUniforms = {\n                \"ShaderMount.ShaderMountImpl.useEffect.updateUniforms\": async ()=>{\n                    const uniforms = await processUniforms(uniformsProp);\n                    if (!isStale) {\n                        shaderMountRef.current?.setUniforms(uniforms);\n                    }\n                }\n            }[\"ShaderMount.ShaderMountImpl.useEffect.updateUniforms\"];\n            updateUniforms();\n            return ({\n                \"ShaderMount.ShaderMountImpl.useEffect\": ()=>{\n                    isStale = true;\n                }\n            })[\"ShaderMount.ShaderMountImpl.useEffect\"];\n        }\n    }[\"ShaderMount.ShaderMountImpl.useEffect\"], [\n        uniformsProp,\n        isInitialized\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"ShaderMount.ShaderMountImpl.useEffect\": ()=>{\n            shaderMountRef.current?.setSpeed(speed);\n        }\n    }[\"ShaderMount.ShaderMountImpl.useEffect\"], [\n        speed,\n        isInitialized\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"ShaderMount.ShaderMountImpl.useEffect\": ()=>{\n            shaderMountRef.current?.setMaxPixelCount(maxPixelCount);\n        }\n    }[\"ShaderMount.ShaderMountImpl.useEffect\"], [\n        maxPixelCount,\n        isInitialized\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"ShaderMount.ShaderMountImpl.useEffect\": ()=>{\n            shaderMountRef.current?.setMinPixelRatio(minPixelRatio);\n        }\n    }[\"ShaderMount.ShaderMountImpl.useEffect\"], [\n        minPixelRatio,\n        isInitialized\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"ShaderMount.ShaderMountImpl.useEffect\": ()=>{\n            shaderMountRef.current?.setFrame(frame);\n        }\n    }[\"ShaderMount.ShaderMountImpl.useEffect\"], [\n        frame,\n        isInitialized\n    ]);\n    const mergedRef = (0,_use_merge_refs_js__WEBPACK_IMPORTED_MODULE_4__.useMergeRefs)([\n        divRef,\n        forwardedRef\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n        ref: mergedRef,\n        style: width !== void 0 || height !== void 0 ? {\n            width,\n            height,\n            ...style\n        } : style,\n        ...divProps\n    });\n});\nShaderMount.displayName = \"ShaderMount\";\n //# sourceMappingURL=shader-mount.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3Qvc2hhZGVyLW1vdW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OzsySEFFd0Q7QUFPakQ7QUFDc0I7QUEwTXZCO0FBbktOLGVBQWUsZ0JBQWdCLGNBQXNFO0lBQ25HLE1BQU0sb0JBQW9CLENBQUM7SUFDM0IsTUFBTSxvQkFBcUMsQ0FBQztJQUU1QyxNQUFNLGFBQWEsQ0FBQztRQUNsQixJQUFJO1lBRUYsSUFBSSxJQUFJLFdBQVcsR0FBRyxFQUFHLFFBQU87WUFFaEMsSUFBSSxJQUFJLEdBQUc7WUFDWCxPQUFPO1FBQ1QsU0FBUTtZQUNOLE9BQU87UUFDVDtJQUNGO0lBRUEsTUFBTSxnQkFBZ0IsQ0FBQztRQUNyQixJQUFJO1lBQ0YsSUFBSSxJQUFJLFdBQVcsR0FBRyxFQUFHLFFBQU87WUFDaEMsTUFBTSxZQUFZLElBQUksSUFBSSxLQUFLLE9BQU8sU0FBUyxNQUFNO1lBQ3JELE9BQU8sVUFBVSxXQUFXLE9BQU8sU0FBUztRQUM5QyxTQUFRO1lBQ04sT0FBTztRQUNUO0lBQ0Y7SUFFQSxPQUFPLFFBQVEsWUFBWSxFQUFFLFFBQVEsQ0FBQyxDQUFDLEtBQUssS0FBSztRQUMvQyxJQUFJLE9BQU8sVUFBVSxVQUFVO1lBRTdCLElBQUksQ0FBQyxPQUFPO2dCQUNWLGtCQUFrQixHQUFHLElBQUksb0VBQWEsQ0FBQztnQkFDdkM7WUFDRjtZQUdBLElBQUksQ0FBQyxXQUFXLEtBQUssR0FBRztnQkFDdEIsUUFBUSxLQUFLLFlBQVksR0FBRyxzQkFBc0IsS0FBSyw0QkFBNEI7Z0JBQ25GO1lBQ0Y7WUFFQSxNQUFNLGVBQWUsSUFBSSxRQUFjLENBQUMsU0FBUztnQkFDL0MsTUFBTSxNQUFNLElBQUksTUFBTTtnQkFDdEIsSUFBSSxjQUFjLEtBQUssR0FBRztvQkFDeEIsSUFBSSxjQUFjO2dCQUNwQjtnQkFDQSxJQUFJLFNBQVM7b0JBQ1gsa0JBQWtCLEdBQUcsSUFBSTtvQkFDekIsUUFBUTtnQkFDVjtnQkFDQSxJQUFJLFVBQVU7b0JBQ1osUUFBUSxNQUFNLG1EQUFtRCxLQUFLLEVBQUU7b0JBQ3hFLE9BQU87Z0JBQ1Q7Z0JBQ0EsSUFBSSxNQUFNO1lBQ1osQ0FBQztZQUNELGtCQUFrQixLQUFLLFlBQVk7UUFDckMsT0FBTztZQUNMLGtCQUFrQixHQUFHLElBQUk7UUFDM0I7SUFDRixDQUFDO0lBRUQsTUFBTSxRQUFRLElBQUksaUJBQWlCO0lBQ25DLE9BQU87QUFDVDtBQU1PLE1BQU0sNEJBQTBDLGlEQUFVLENBQy9ELFNBQVMsZ0JBQ1AsRUFDRSxnQkFDQSxVQUFVLGNBQ1Ysd0JBQ0EsUUFBUSxHQUNSLFFBQVEsR0FDUixPQUNBLFFBQ0EsZUFDQSxlQUNBLE9BQ0EsR0FBRyxVQUNMLEVBQ0EsY0FDQTtJQUNBLE1BQU0sQ0FBQyxlQUFlLGdCQUFnQixJQUFJLCtDQUFRLENBQUMsS0FBSztJQUN4RCxNQUFNLFNBQVMsNkNBQU0sQ0FBcUIsSUFBSTtJQUM5QyxNQUFNLGlCQUE2RCw2Q0FBTSxDQUFxQixJQUFJO0lBQ2xHLE1BQU0sNEJBQTRCLDZDQUFNLENBQUMsc0JBQXNCO0lBRy9ELGdEQUFTO2lEQUFDO1lBQ1IsTUFBTTtvRUFBYTtvQkFDakIsTUFBTSxXQUFXLE1BQU0sZ0JBQWdCLFlBQVk7b0JBRW5ELElBQUksT0FBTyxXQUFXLENBQUMsZUFBZSxTQUFTO3dCQUM3QyxlQUFlLFVBQVUsSUFBSSw4REFBa0IsQ0FDN0MsT0FBTyxTQUNQLGdCQUNBLFVBQ0EsMEJBQTBCLFNBQzFCLE9BQ0EsT0FDQSxlQUNBO3dCQUdGLGlCQUFpQixJQUFJO29CQUN2QjtnQkFDRjs7WUFFQSxXQUFXO1lBRVg7eURBQU87b0JBQ0wsZUFBZSxTQUFTLFFBQVE7b0JBQ2hDLGVBQWUsVUFBVTtnQkFDM0I7O1FBQ0Y7Z0RBQUc7UUFBQyxjQUFjO0tBQUM7SUFHbkIsZ0RBQVM7aURBQUM7WUFDUixJQUFJLFVBQVU7WUFFZCxNQUFNO3dFQUFpQjtvQkFDckIsTUFBTSxXQUFXLE1BQU0sZ0JBQWdCLFlBQVk7b0JBRW5ELElBQUksQ0FBQyxTQUFTO3dCQUdaLGVBQWUsU0FBUyxZQUFZLFFBQVE7b0JBQzlDO2dCQUNGOztZQUVBLGVBQWU7WUFFZjt5REFBTztvQkFDTCxVQUFVO2dCQUNaOztRQUNGO2dEQUFHO1FBQUM7UUFBYyxhQUFhO0tBQUM7SUFHaEMsZ0RBQVM7aURBQUM7WUFDUixlQUFlLFNBQVMsU0FBUyxLQUFLO1FBQ3hDO2dEQUFHO1FBQUM7UUFBTyxhQUFhO0tBQUM7SUFHekIsZ0RBQVM7aURBQUM7WUFDUixlQUFlLFNBQVMsaUJBQWlCLGFBQWE7UUFDeEQ7Z0RBQUc7UUFBQztRQUFlLGFBQWE7S0FBQztJQUdqQyxnREFBUztpREFBQztZQUNSLGVBQWUsU0FBUyxpQkFBaUIsYUFBYTtRQUN4RDtnREFBRztRQUFDO1FBQWUsYUFBYTtLQUFDO0lBR2pDLGdEQUFTO2lEQUFDO1lBQ1IsZUFBZSxTQUFTLFNBQVMsS0FBSztRQUN4QztnREFBRztRQUFDO1FBQU8sYUFBYTtLQUFDO0lBRXpCLE1BQU0sWUFBWSxnRUFBWSxDQUFDO1FBQUM7UUFBUSxZQUFZO0tBQUM7SUFDckQsT0FDRSx1RUFBQztRQUNDLEtBQUs7UUFDTCxPQUFPLFVBQVUsVUFBYSxXQUFXLFNBQVk7WUFBRTtZQUFPO1lBQVEsR0FBRztRQUFNLElBQUk7UUFDbEYsR0FBRztJQUFBO0FBR1Y7QUFHRixZQUFZLGNBQWMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcnR0aWNmb3gvRGVza3RvcC9Xb3JrL3NyYy9zaGFkZXItbW91bnQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIGZvcndhcmRSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHtcbiAgU2hhZGVyTW91bnQgYXMgU2hhZGVyTW91bnRWYW5pbGxhLFxuICBnZXRFbXB0eVBpeGVsLFxuICB0eXBlIFBhcGVyU2hhZGVyRWxlbWVudCxcbiAgdHlwZSBTaGFkZXJNb3Rpb25QYXJhbXMsXG4gIHR5cGUgU2hhZGVyTW91bnRVbmlmb3Jtcyxcbn0gZnJvbSAnQHBhcGVyLWRlc2lnbi9zaGFkZXJzJztcbmltcG9ydCB7IHVzZU1lcmdlUmVmcyB9IGZyb20gJy4vdXNlLW1lcmdlLXJlZnMuanMnO1xuXG4vKipcbiAqIFJlYWN0IFNoYWRlciBNb3VudCBjYW4gYWxzbyBhY2NlcHQgc3RyaW5ncyBhcyB1bmlmb3JtIHZhbHVlcywgd2hpY2ggd2lsbCBhc3N1bWVkIHRvIGJlIFVSTHMgYW5kIGxvYWRlZCBhcyBpbWFnZXNcbiAqXG4gKiBXZSBhY2NlcHQgdW5kZWZpbmVkIGFzIGEgY29udmVuaWVuY2UgZm9yIHNlcnZlciByZW5kZXJpbmcsIHdoZW4gc29tZSB0aGluZ3MgbWF5IGJlIHVuZGVmaW5lZFxuICogV2UganVzdCBza2lwIHNldHRpbmcgdGhlIHVuaWZvcm0gaWYgaXQncyB1bmRlZmluZWQuIFRoaXMgYWxsb3dzIHRoZSBzaGFkZXIgbW91bnQgdG8gc3RpbGwgdGFrZSB1cCBzcGFjZSBkdXJpbmcgc2VydmVyIHJlbmRlcmluZ1xuICovXG5pbnRlcmZhY2UgU2hhZGVyTW91bnRVbmlmb3Jtc1JlYWN0IHtcbiAgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgYm9vbGVhbiB8IG51bWJlciB8IG51bWJlcltdIHwgbnVtYmVyW11bXSB8IEhUTUxJbWFnZUVsZW1lbnQgfCB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2hhZGVyTW91bnRQcm9wcyBleHRlbmRzIE9taXQ8UmVhY3QuQ29tcG9uZW50UHJvcHM8J2Rpdic+LCAnY29sb3InIHwgJ3JlZic+LCBTaGFkZXJNb3Rpb25QYXJhbXMge1xuICByZWY/OiBSZWFjdC5SZWY8UGFwZXJTaGFkZXJFbGVtZW50PjtcbiAgZnJhZ21lbnRTaGFkZXI6IHN0cmluZztcbiAgdW5pZm9ybXM6IFNoYWRlck1vdW50VW5pZm9ybXNSZWFjdDtcbiAgbWluUGl4ZWxSYXRpbz86IG51bWJlcjtcbiAgbWF4UGl4ZWxDb3VudD86IG51bWJlcjtcbiAgd2ViR2xDb250ZXh0QXR0cmlidXRlcz86IFdlYkdMQ29udGV4dEF0dHJpYnV0ZXM7XG5cbiAgLyoqIElubGluZSBDU1Mgd2lkdGggc3R5bGUgKi9cbiAgd2lkdGg/OiBzdHJpbmcgfCBudW1iZXI7XG4gIC8qKiBJbmxpbmUgQ1NTIGhlaWdodCBzdHlsZSAqL1xuICBoZWlnaHQ/OiBzdHJpbmcgfCBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2hhZGVyQ29tcG9uZW50UHJvcHMgZXh0ZW5kcyBPbWl0PFJlYWN0LkNvbXBvbmVudFByb3BzPCdkaXYnPiwgJ2NvbG9yJyB8ICdyZWYnPiB7XG4gIHJlZj86IFJlYWN0LlJlZjxQYXBlclNoYWRlckVsZW1lbnQ+O1xuICBtaW5QaXhlbFJhdGlvPzogbnVtYmVyO1xuICBtYXhQaXhlbENvdW50PzogbnVtYmVyO1xuICB3ZWJHbENvbnRleHRBdHRyaWJ1dGVzPzogV2ViR0xDb250ZXh0QXR0cmlidXRlcztcblxuICAvKiogSW5saW5lIENTUyB3aWR0aCBzdHlsZSAqL1xuICB3aWR0aD86IHN0cmluZyB8IG51bWJlcjtcbiAgLyoqIElubGluZSBDU1MgaGVpZ2h0IHN0eWxlICovXG4gIGhlaWdodD86IHN0cmluZyB8IG51bWJlcjtcbn1cblxuLyoqIFBhcnNlIHRoZSBwcm92aWRlZCB1bmlmb3JtcywgdHVybmluZyBVUkwgc3RyaW5ncyBpbnRvIGxvYWRlZCBpbWFnZXMgKi9cbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NVbmlmb3Jtcyh1bmlmb3Jtc1Byb3A6IFNoYWRlck1vdW50VW5pZm9ybXNSZWFjdCk6IFByb21pc2U8U2hhZGVyTW91bnRVbmlmb3Jtcz4ge1xuICBjb25zdCBwcm9jZXNzZWRVbmlmb3JtcyA9IHt9IGFzIFNoYWRlck1vdW50VW5pZm9ybXM7XG4gIGNvbnN0IGltYWdlTG9hZFByb21pc2VzOiBQcm9taXNlPHZvaWQ+W10gPSBbXTtcblxuICBjb25zdCBpc1ZhbGlkVXJsID0gKHVybDogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEhhbmRsZSBhYnNvbHV0ZSBwYXRoc1xuICAgICAgaWYgKHVybC5zdGFydHNXaXRoKCcvJykpIHJldHVybiB0cnVlO1xuICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhIHZhbGlkIFVSTFxuICAgICAgbmV3IFVSTCh1cmwpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGlzRXh0ZXJuYWxVcmwgPSAodXJsOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKHVybC5zdGFydHNXaXRoKCcvJykpIHJldHVybiBmYWxzZTtcbiAgICAgIGNvbnN0IHVybE9iamVjdCA9IG5ldyBVUkwodXJsLCB3aW5kb3cubG9jYXRpb24ub3JpZ2luKTtcbiAgICAgIHJldHVybiB1cmxPYmplY3Qub3JpZ2luICE9PSB3aW5kb3cubG9jYXRpb24ub3JpZ2luO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBPYmplY3QuZW50cmllcyh1bmlmb3Jtc1Byb3ApLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBVc2UgYSB0cmFuc3BhcmVudCBwaXhlbCBmb3IgZW1wdHkgc3RyaW5nc1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICBwcm9jZXNzZWRVbmlmb3Jtc1trZXldID0gZ2V0RW1wdHlQaXhlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgcHJvdmlkZWQgc3RyaW5nIGlzIGEgdmFsaWQgVVJMIG9yIGp1c3Qgc2tpcCB0cnlpbmcgdG8gc2V0IHRoaXMgdW5pZm9ybSBlbnRpcmVseVxuICAgICAgaWYgKCFpc1ZhbGlkVXJsKHZhbHVlKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYFVuaWZvcm0gXCIke2tleX1cIiBoYXMgaW52YWxpZCBVUkwgXCIke3ZhbHVlfVwiLiBTa2lwcGluZyBpbWFnZSBsb2FkaW5nLmApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGltYWdlUHJvbWlzZSA9IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGlmIChpc0V4dGVybmFsVXJsKHZhbHVlKSkge1xuICAgICAgICAgIGltZy5jcm9zc09yaWdpbiA9ICdhbm9ueW1vdXMnO1xuICAgICAgICB9XG4gICAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgcHJvY2Vzc2VkVW5pZm9ybXNba2V5XSA9IGltZztcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH07XG4gICAgICAgIGltZy5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYENvdWxkIG5vdCBzZXQgdW5pZm9ybXMuIEZhaWxlZCB0byBsb2FkIGltYWdlIGF0ICR7dmFsdWV9YCk7XG4gICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgIH07XG4gICAgICAgIGltZy5zcmMgPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgICAgaW1hZ2VMb2FkUHJvbWlzZXMucHVzaChpbWFnZVByb21pc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzZWRVbmlmb3Jtc1trZXldID0gdmFsdWU7XG4gICAgfVxuICB9KTtcblxuICBhd2FpdCBQcm9taXNlLmFsbChpbWFnZUxvYWRQcm9taXNlcyk7XG4gIHJldHVybiBwcm9jZXNzZWRVbmlmb3Jtcztcbn1cblxuLyoqXG4gKiBBIFJlYWN0IGNvbXBvbmVudCB0aGF0IG1vdW50cyBhIHNoYWRlciBhbmQgdXBkYXRlcyBpdHMgdW5pZm9ybXMgYXMgdGhlIGNvbXBvbmVudCdzIHByb3BzIGNoYW5nZVxuICogSWYgeW91IHBhc3MgYSBzdHJpbmcgYXMgYSB1bmlmb3JtIHZhbHVlLCBpdCB3aWxsIGJlIGFzc3VtZWQgdG8gYmUgYSBVUkwgYW5kIGF0dGVtcHRlZCB0byBiZSBsb2FkZWQgYXMgYW4gaW1hZ2VcbiAqL1xuZXhwb3J0IGNvbnN0IFNoYWRlck1vdW50OiBSZWFjdC5GQzxTaGFkZXJNb3VudFByb3BzPiA9IGZvcndhcmRSZWY8UGFwZXJTaGFkZXJFbGVtZW50LCBTaGFkZXJNb3VudFByb3BzPihcbiAgZnVuY3Rpb24gU2hhZGVyTW91bnRJbXBsKFxuICAgIHtcbiAgICAgIGZyYWdtZW50U2hhZGVyLFxuICAgICAgdW5pZm9ybXM6IHVuaWZvcm1zUHJvcCxcbiAgICAgIHdlYkdsQ29udGV4dEF0dHJpYnV0ZXMsXG4gICAgICBzcGVlZCA9IDAsXG4gICAgICBmcmFtZSA9IDAsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIG1pblBpeGVsUmF0aW8sXG4gICAgICBtYXhQaXhlbENvdW50LFxuICAgICAgc3R5bGUsXG4gICAgICAuLi5kaXZQcm9wc1xuICAgIH0sXG4gICAgZm9yd2FyZGVkUmVmXG4gICkge1xuICAgIGNvbnN0IFtpc0luaXRpYWxpemVkLCBzZXRJc0luaXRpYWxpemVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBkaXZSZWYgPSB1c2VSZWY8UGFwZXJTaGFkZXJFbGVtZW50PihudWxsKTtcbiAgICBjb25zdCBzaGFkZXJNb3VudFJlZjogUmVhY3QuUmVmT2JqZWN0PFNoYWRlck1vdW50VmFuaWxsYSB8IG51bGw+ID0gdXNlUmVmPFNoYWRlck1vdW50VmFuaWxsYT4obnVsbCk7XG4gICAgY29uc3Qgd2ViR2xDb250ZXh0QXR0cmlidXRlc1JlZiA9IHVzZVJlZih3ZWJHbENvbnRleHRBdHRyaWJ1dGVzKTtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIFNoYWRlck1vdW50VmFuaWxsYVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBjb25zdCBpbml0U2hhZGVyID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCB1bmlmb3JtcyA9IGF3YWl0IHByb2Nlc3NVbmlmb3Jtcyh1bmlmb3Jtc1Byb3ApO1xuXG4gICAgICAgIGlmIChkaXZSZWYuY3VycmVudCAmJiAhc2hhZGVyTW91bnRSZWYuY3VycmVudCkge1xuICAgICAgICAgIHNoYWRlck1vdW50UmVmLmN1cnJlbnQgPSBuZXcgU2hhZGVyTW91bnRWYW5pbGxhKFxuICAgICAgICAgICAgZGl2UmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBmcmFnbWVudFNoYWRlcixcbiAgICAgICAgICAgIHVuaWZvcm1zLFxuICAgICAgICAgICAgd2ViR2xDb250ZXh0QXR0cmlidXRlc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgc3BlZWQsXG4gICAgICAgICAgICBmcmFtZSxcbiAgICAgICAgICAgIG1pblBpeGVsUmF0aW8sXG4gICAgICAgICAgICBtYXhQaXhlbENvdW50XG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHNldElzSW5pdGlhbGl6ZWQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGluaXRTaGFkZXIoKTtcblxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgc2hhZGVyTW91bnRSZWYuY3VycmVudD8uZGlzcG9zZSgpO1xuICAgICAgICBzaGFkZXJNb3VudFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH07XG4gICAgfSwgW2ZyYWdtZW50U2hhZGVyXSk7XG5cbiAgICAvLyBVbmlmb3Jtc1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBsZXQgaXNTdGFsZSA9IGZhbHNlO1xuXG4gICAgICBjb25zdCB1cGRhdGVVbmlmb3JtcyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgdW5pZm9ybXMgPSBhd2FpdCBwcm9jZXNzVW5pZm9ybXModW5pZm9ybXNQcm9wKTtcblxuICAgICAgICBpZiAoIWlzU3RhbGUpIHtcbiAgICAgICAgICAvLyBXZSBvbmx5IHVzZSB0aGUgZnJlc2hlc3QgdW5pZm9ybXMgb3RoZXJ3aXNlIHdlIGNhbiBnZXQgaW50byByYWNlIGNvbmRpdGlvbnNcbiAgICAgICAgICAvLyBpZiBzb21lIHVuaWZvcm1zIChpbWFnZXMhKSB0YWtlIGxvbmdlciB0byBsb2FkIGluIHN1YnNlcXVlbnQgZWZmZWN0IHJ1bnMuXG4gICAgICAgICAgc2hhZGVyTW91bnRSZWYuY3VycmVudD8uc2V0VW5pZm9ybXModW5pZm9ybXMpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB1cGRhdGVVbmlmb3JtcygpO1xuXG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpc1N0YWxlID0gdHJ1ZTtcbiAgICAgIH07XG4gICAgfSwgW3VuaWZvcm1zUHJvcCwgaXNJbml0aWFsaXplZF0pO1xuXG4gICAgLy8gU3BlZWRcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgc2hhZGVyTW91bnRSZWYuY3VycmVudD8uc2V0U3BlZWQoc3BlZWQpO1xuICAgIH0sIFtzcGVlZCwgaXNJbml0aWFsaXplZF0pO1xuXG4gICAgLy8gTWF4IFBpeGVsIENvdW50XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIHNoYWRlck1vdW50UmVmLmN1cnJlbnQ/LnNldE1heFBpeGVsQ291bnQobWF4UGl4ZWxDb3VudCk7XG4gICAgfSwgW21heFBpeGVsQ291bnQsIGlzSW5pdGlhbGl6ZWRdKTtcblxuICAgIC8vIE1pbiBQaXhlbCBSYXRpb1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBzaGFkZXJNb3VudFJlZi5jdXJyZW50Py5zZXRNaW5QaXhlbFJhdGlvKG1pblBpeGVsUmF0aW8pO1xuICAgIH0sIFttaW5QaXhlbFJhdGlvLCBpc0luaXRpYWxpemVkXSk7XG5cbiAgICAvLyBGcmFtZVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBzaGFkZXJNb3VudFJlZi5jdXJyZW50Py5zZXRGcmFtZShmcmFtZSk7XG4gICAgfSwgW2ZyYW1lLCBpc0luaXRpYWxpemVkXSk7XG5cbiAgICBjb25zdCBtZXJnZWRSZWYgPSB1c2VNZXJnZVJlZnMoW2RpdlJlZiwgZm9yd2FyZGVkUmVmXSkgYXMgdW5rbm93biBhcyBSZWFjdC5SZWZPYmplY3Q8SFRNTERpdkVsZW1lbnQ+O1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2XG4gICAgICAgIHJlZj17bWVyZ2VkUmVmfVxuICAgICAgICBzdHlsZT17d2lkdGggIT09IHVuZGVmaW5lZCB8fCBoZWlnaHQgIT09IHVuZGVmaW5lZCA/IHsgd2lkdGgsIGhlaWdodCwgLi4uc3R5bGUgfSA6IHN0eWxlfVxuICAgICAgICB7Li4uZGl2UHJvcHN9XG4gICAgICAvPlxuICAgICk7XG4gIH1cbik7XG5cblNoYWRlck1vdW50LmRpc3BsYXlOYW1lID0gJ1NoYWRlck1vdW50JztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders-react/dist/shader-mount.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders-react/dist/shaders/swirl.js":
/*!************************************************************************!*\
  !*** ./node_modules/@paper-design/shaders-react/dist/shaders/swirl.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Swirl: () => (/* binding */ Swirl),\n/* harmony export */   candyPreset: () => (/* binding */ candyPreset),\n/* harmony export */   defaultPreset: () => (/* binding */ defaultPreset),\n/* harmony export */   jamesBondPreset: () => (/* binding */ jamesBondPreset),\n/* harmony export */   openingPreset: () => (/* binding */ openingPreset),\n/* harmony export */   swirlPresets: () => (/* binding */ swirlPresets)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _shader_mount_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shader-mount.js */ \"(ssr)/./node_modules/@paper-design/shaders-react/dist/shader-mount.js\");\n/* harmony import */ var _paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @paper-design/shaders */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shader-sizing.js\");\n/* harmony import */ var _paper_design_shaders__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @paper-design/shaders */ \"(ssr)/./node_modules/@paper-design/shaders/dist/get-shader-color-from-string.js\");\n/* harmony import */ var _paper_design_shaders__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @paper-design/shaders */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shaders/swirl.js\");\n/* harmony import */ var _color_props_are_equal_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../color-props-are-equal.js */ \"(ssr)/./node_modules/@paper-design/shaders-react/dist/color-props-are-equal.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\n\n\n\n\nconst defaultPreset = {\n  name: \"Default\",\n  params: {\n    ..._paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.defaultObjectSizing,\n    speed: 0.32,\n    frame: 0,\n    colorBack: \"#330000\",\n    colors: [\"#ffd1d1\", \"#ff8a8a\", \"#660000\"],\n    bandCount: 4,\n    twist: 0.1,\n    center: 0.2,\n    proportion: 0.5,\n    softness: 0,\n    noiseFrequency: 0.4,\n    noise: 0.2\n  }\n};\nconst openingPreset = {\n  name: \"Opening\",\n  params: {\n    ..._paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.defaultObjectSizing,\n    offsetX: -0.4,\n    offsetY: 1,\n    speed: 0.5,\n    frame: 0,\n    colorBack: \"#ff8b61\",\n    colors: [\"#fefff0\", \"#ffd8bd\", \"#ff8b61\"],\n    bandCount: 2,\n    twist: 0.3,\n    center: 0.2,\n    proportion: 0.5,\n    softness: 0,\n    noiseFrequency: 0,\n    noise: 0,\n    scale: 1\n  }\n};\nconst jamesBondPreset = {\n  name: \"007\",\n  params: {\n    ..._paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    colorBack: \"#E9E7DA\",\n    colors: [\"#000000\"],\n    bandCount: 5,\n    twist: 0.3,\n    center: 0,\n    proportion: 0,\n    softness: 0,\n    noiseFrequency: 0.5,\n    noise: 0\n  }\n};\nconst candyPreset = {\n  name: \"Candy\",\n  params: {\n    ..._paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    colorBack: \"#ffcd66\",\n    colors: [\"#6bbceb\", \"#d7b3ff\", \"#ff9fff\"],\n    bandCount: 2,\n    twist: 0.15,\n    center: 0.2,\n    proportion: 0.5,\n    softness: 1,\n    noiseFrequency: 0.5,\n    noise: 0\n  }\n};\nconst swirlPresets = [defaultPreset, jamesBondPreset, openingPreset, candyPreset];\nconst Swirl = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(function SwirlImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colorBack = defaultPreset.params.colorBack,\n  colors = defaultPreset.params.colors,\n  bandCount = defaultPreset.params.bandCount,\n  twist = defaultPreset.params.twist,\n  center = defaultPreset.params.center,\n  proportion = defaultPreset.params.proportion,\n  softness = defaultPreset.params.softness,\n  noiseFrequency = defaultPreset.params.noiseFrequency,\n  noise = defaultPreset.params.noise,\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  rotation = defaultPreset.params.rotation,\n  scale = defaultPreset.params.scale,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}) {\n  const uniforms = {\n    // Own uniforms\n    u_colorBack: (0,_paper_design_shaders__WEBPACK_IMPORTED_MODULE_3__.getShaderColorFromString)(colorBack),\n    u_colors: colors.map(_paper_design_shaders__WEBPACK_IMPORTED_MODULE_3__.getShaderColorFromString),\n    u_colorsCount: colors.length,\n    u_bandCount: bandCount,\n    u_twist: twist,\n    u_center: center,\n    u_proportion: proportion,\n    u_softness: softness,\n    u_noiseFrequency: noiseFrequency,\n    u_noise: noise,\n    // Sizing uniforms\n    u_fit: _paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.ShaderFitOptions[fit],\n    u_scale: scale,\n    u_rotation: rotation,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight\n  };\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_shader_mount_js__WEBPACK_IMPORTED_MODULE_4__.ShaderMount, { ...props, speed, frame, fragmentShader: _paper_design_shaders__WEBPACK_IMPORTED_MODULE_5__.swirlFragmentShader, uniforms });\n}, _color_props_are_equal_js__WEBPACK_IMPORTED_MODULE_6__.colorPropsAreEqual);\n\n//# sourceMappingURL=swirl.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3Qvc2hhZGVycy9zd2lybC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRTZCO0FBQ29CO0FBTWxCO0FBQ2tDO0FBQ3pCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLE9BQU8sc0VBQW1CO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxzRUFBbUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHNFQUFtQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sc0VBQW1CO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJDQUFJO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGlCQUFpQiwrRUFBd0I7QUFDekMseUJBQXlCLDJFQUF3QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1FQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0RBQUcsQ0FBQyx5REFBVyxJQUFJLHdDQUF3QyxzRUFBbUIsWUFBWTtBQUNuSCxDQUFDLEVBQUUseUVBQWtCO0FBUW5CO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcnR0aWNmb3gvRGVza3RvcC9Xb3JrL3Bob3RvYXBwL25vZGVfbW9kdWxlcy9AcGFwZXItZGVzaWduL3NoYWRlcnMtcmVhY3QvZGlzdC9zaGFkZXJzL3N3aXJsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiAgICAgICAgICAgICAgICAgICAgUGFwZXIgU2hhZGVycyAgICAgICAgICAgICAgICAgICAgKlxuICogICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3BhcGVyLWRlc2lnbi9zaGFkZXJzICAgICAgICpcbiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuXG5pbXBvcnQgeyBtZW1vIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBTaGFkZXJNb3VudCB9IGZyb20gXCIuLi9zaGFkZXItbW91bnQuanNcIjtcbmltcG9ydCB7XG4gIGRlZmF1bHRPYmplY3RTaXppbmcsXG4gIGdldFNoYWRlckNvbG9yRnJvbVN0cmluZyxcbiAgU2hhZGVyRml0T3B0aW9ucyxcbiAgc3dpcmxGcmFnbWVudFNoYWRlclxufSBmcm9tIFwiQHBhcGVyLWRlc2lnbi9zaGFkZXJzXCI7XG5pbXBvcnQgeyBjb2xvclByb3BzQXJlRXF1YWwgfSBmcm9tIFwiLi4vY29sb3ItcHJvcHMtYXJlLWVxdWFsLmpzXCI7XG5pbXBvcnQgeyBqc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmNvbnN0IGRlZmF1bHRQcmVzZXQgPSB7XG4gIG5hbWU6IFwiRGVmYXVsdFwiLFxuICBwYXJhbXM6IHtcbiAgICAuLi5kZWZhdWx0T2JqZWN0U2l6aW5nLFxuICAgIHNwZWVkOiAwLjMyLFxuICAgIGZyYW1lOiAwLFxuICAgIGNvbG9yQmFjazogXCIjMzMwMDAwXCIsXG4gICAgY29sb3JzOiBbXCIjZmZkMWQxXCIsIFwiI2ZmOGE4YVwiLCBcIiM2NjAwMDBcIl0sXG4gICAgYmFuZENvdW50OiA0LFxuICAgIHR3aXN0OiAwLjEsXG4gICAgY2VudGVyOiAwLjIsXG4gICAgcHJvcG9ydGlvbjogMC41LFxuICAgIHNvZnRuZXNzOiAwLFxuICAgIG5vaXNlRnJlcXVlbmN5OiAwLjQsXG4gICAgbm9pc2U6IDAuMlxuICB9XG59O1xuY29uc3Qgb3BlbmluZ1ByZXNldCA9IHtcbiAgbmFtZTogXCJPcGVuaW5nXCIsXG4gIHBhcmFtczoge1xuICAgIC4uLmRlZmF1bHRPYmplY3RTaXppbmcsXG4gICAgb2Zmc2V0WDogLTAuNCxcbiAgICBvZmZzZXRZOiAxLFxuICAgIHNwZWVkOiAwLjUsXG4gICAgZnJhbWU6IDAsXG4gICAgY29sb3JCYWNrOiBcIiNmZjhiNjFcIixcbiAgICBjb2xvcnM6IFtcIiNmZWZmZjBcIiwgXCIjZmZkOGJkXCIsIFwiI2ZmOGI2MVwiXSxcbiAgICBiYW5kQ291bnQ6IDIsXG4gICAgdHdpc3Q6IDAuMyxcbiAgICBjZW50ZXI6IDAuMixcbiAgICBwcm9wb3J0aW9uOiAwLjUsXG4gICAgc29mdG5lc3M6IDAsXG4gICAgbm9pc2VGcmVxdWVuY3k6IDAsXG4gICAgbm9pc2U6IDAsXG4gICAgc2NhbGU6IDFcbiAgfVxufTtcbmNvbnN0IGphbWVzQm9uZFByZXNldCA9IHtcbiAgbmFtZTogXCIwMDdcIixcbiAgcGFyYW1zOiB7XG4gICAgLi4uZGVmYXVsdE9iamVjdFNpemluZyxcbiAgICBzcGVlZDogMSxcbiAgICBmcmFtZTogMCxcbiAgICBjb2xvckJhY2s6IFwiI0U5RTdEQVwiLFxuICAgIGNvbG9yczogW1wiIzAwMDAwMFwiXSxcbiAgICBiYW5kQ291bnQ6IDUsXG4gICAgdHdpc3Q6IDAuMyxcbiAgICBjZW50ZXI6IDAsXG4gICAgcHJvcG9ydGlvbjogMCxcbiAgICBzb2Z0bmVzczogMCxcbiAgICBub2lzZUZyZXF1ZW5jeTogMC41LFxuICAgIG5vaXNlOiAwXG4gIH1cbn07XG5jb25zdCBjYW5keVByZXNldCA9IHtcbiAgbmFtZTogXCJDYW5keVwiLFxuICBwYXJhbXM6IHtcbiAgICAuLi5kZWZhdWx0T2JqZWN0U2l6aW5nLFxuICAgIHNwZWVkOiAxLFxuICAgIGZyYW1lOiAwLFxuICAgIGNvbG9yQmFjazogXCIjZmZjZDY2XCIsXG4gICAgY29sb3JzOiBbXCIjNmJiY2ViXCIsIFwiI2Q3YjNmZlwiLCBcIiNmZjlmZmZcIl0sXG4gICAgYmFuZENvdW50OiAyLFxuICAgIHR3aXN0OiAwLjE1LFxuICAgIGNlbnRlcjogMC4yLFxuICAgIHByb3BvcnRpb246IDAuNSxcbiAgICBzb2Z0bmVzczogMSxcbiAgICBub2lzZUZyZXF1ZW5jeTogMC41LFxuICAgIG5vaXNlOiAwXG4gIH1cbn07XG5jb25zdCBzd2lybFByZXNldHMgPSBbZGVmYXVsdFByZXNldCwgamFtZXNCb25kUHJlc2V0LCBvcGVuaW5nUHJlc2V0LCBjYW5keVByZXNldF07XG5jb25zdCBTd2lybCA9IG1lbW8oZnVuY3Rpb24gU3dpcmxJbXBsKHtcbiAgLy8gT3duIHByb3BzXG4gIHNwZWVkID0gZGVmYXVsdFByZXNldC5wYXJhbXMuc3BlZWQsXG4gIGZyYW1lID0gZGVmYXVsdFByZXNldC5wYXJhbXMuZnJhbWUsXG4gIGNvbG9yQmFjayA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLmNvbG9yQmFjayxcbiAgY29sb3JzID0gZGVmYXVsdFByZXNldC5wYXJhbXMuY29sb3JzLFxuICBiYW5kQ291bnQgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5iYW5kQ291bnQsXG4gIHR3aXN0ID0gZGVmYXVsdFByZXNldC5wYXJhbXMudHdpc3QsXG4gIGNlbnRlciA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLmNlbnRlcixcbiAgcHJvcG9ydGlvbiA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLnByb3BvcnRpb24sXG4gIHNvZnRuZXNzID0gZGVmYXVsdFByZXNldC5wYXJhbXMuc29mdG5lc3MsXG4gIG5vaXNlRnJlcXVlbmN5ID0gZGVmYXVsdFByZXNldC5wYXJhbXMubm9pc2VGcmVxdWVuY3ksXG4gIG5vaXNlID0gZGVmYXVsdFByZXNldC5wYXJhbXMubm9pc2UsXG4gIC8vIFNpemluZyBwcm9wc1xuICBmaXQgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5maXQsXG4gIHJvdGF0aW9uID0gZGVmYXVsdFByZXNldC5wYXJhbXMucm90YXRpb24sXG4gIHNjYWxlID0gZGVmYXVsdFByZXNldC5wYXJhbXMuc2NhbGUsXG4gIG9yaWdpblggPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5vcmlnaW5YLFxuICBvcmlnaW5ZID0gZGVmYXVsdFByZXNldC5wYXJhbXMub3JpZ2luWSxcbiAgb2Zmc2V0WCA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLm9mZnNldFgsXG4gIG9mZnNldFkgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5vZmZzZXRZLFxuICB3b3JsZFdpZHRoID0gZGVmYXVsdFByZXNldC5wYXJhbXMud29ybGRXaWR0aCxcbiAgd29ybGRIZWlnaHQgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy53b3JsZEhlaWdodCxcbiAgLi4ucHJvcHNcbn0pIHtcbiAgY29uc3QgdW5pZm9ybXMgPSB7XG4gICAgLy8gT3duIHVuaWZvcm1zXG4gICAgdV9jb2xvckJhY2s6IGdldFNoYWRlckNvbG9yRnJvbVN0cmluZyhjb2xvckJhY2spLFxuICAgIHVfY29sb3JzOiBjb2xvcnMubWFwKGdldFNoYWRlckNvbG9yRnJvbVN0cmluZyksXG4gICAgdV9jb2xvcnNDb3VudDogY29sb3JzLmxlbmd0aCxcbiAgICB1X2JhbmRDb3VudDogYmFuZENvdW50LFxuICAgIHVfdHdpc3Q6IHR3aXN0LFxuICAgIHVfY2VudGVyOiBjZW50ZXIsXG4gICAgdV9wcm9wb3J0aW9uOiBwcm9wb3J0aW9uLFxuICAgIHVfc29mdG5lc3M6IHNvZnRuZXNzLFxuICAgIHVfbm9pc2VGcmVxdWVuY3k6IG5vaXNlRnJlcXVlbmN5LFxuICAgIHVfbm9pc2U6IG5vaXNlLFxuICAgIC8vIFNpemluZyB1bmlmb3Jtc1xuICAgIHVfZml0OiBTaGFkZXJGaXRPcHRpb25zW2ZpdF0sXG4gICAgdV9zY2FsZTogc2NhbGUsXG4gICAgdV9yb3RhdGlvbjogcm90YXRpb24sXG4gICAgdV9vZmZzZXRYOiBvZmZzZXRYLFxuICAgIHVfb2Zmc2V0WTogb2Zmc2V0WSxcbiAgICB1X29yaWdpblg6IG9yaWdpblgsXG4gICAgdV9vcmlnaW5ZOiBvcmlnaW5ZLFxuICAgIHVfd29ybGRXaWR0aDogd29ybGRXaWR0aCxcbiAgICB1X3dvcmxkSGVpZ2h0OiB3b3JsZEhlaWdodFxuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChTaGFkZXJNb3VudCwgeyAuLi5wcm9wcywgc3BlZWQsIGZyYW1lLCBmcmFnbWVudFNoYWRlcjogc3dpcmxGcmFnbWVudFNoYWRlciwgdW5pZm9ybXMgfSk7XG59LCBjb2xvclByb3BzQXJlRXF1YWwpO1xuZXhwb3J0IHtcbiAgU3dpcmwsXG4gIGNhbmR5UHJlc2V0LFxuICBkZWZhdWx0UHJlc2V0LFxuICBqYW1lc0JvbmRQcmVzZXQsXG4gIG9wZW5pbmdQcmVzZXQsXG4gIHN3aXJsUHJlc2V0c1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN3aXJsLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders-react/dist/shaders/swirl.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders-react/dist/use-merge-refs.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@paper-design/shaders-react/dist/use-merge-refs.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useMergeRefs: () => (/* binding */ useMergeRefs)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\nfunction useMergeRefs(refs) {\n  const cleanupRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);\n  const refEffect = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((instance) => {\n    const cleanups = refs.map((ref) => {\n      if (ref == null) {\n        return;\n      }\n      if (typeof ref === \"function\") {\n        const refCallback = ref;\n        const refCleanup = refCallback(instance);\n        return typeof refCleanup === \"function\" ? refCleanup : () => {\n          refCallback(null);\n        };\n      }\n      ref.current = instance;\n      return () => {\n        ref.current = null;\n      };\n    });\n    return () => {\n      cleanups.forEach((refCleanup) => refCleanup?.());\n    };\n  }, refs);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (refs.every((ref) => ref == null)) {\n      return null;\n    }\n    return (value) => {\n      if (cleanupRef.current) {\n        cleanupRef.current();\n        cleanupRef.current = void 0;\n      }\n      if (value != null) {\n        cleanupRef.current = refEffect(value);\n      }\n    };\n  }, refs);\n}\n\n//# sourceMappingURL=use-merge-refs.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3QvdXNlLW1lcmdlLXJlZnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0I7QUFDL0I7QUFDQSxxQkFBcUIseUNBQVk7QUFDakMsb0JBQW9CLDhDQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFNBQVMsMENBQWE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2FydHRpY2ZveC9EZXNrdG9wL1dvcmsvcGhvdG9hcHAvbm9kZV9tb2R1bGVzL0BwYXBlci1kZXNpZ24vc2hhZGVycy1yZWFjdC9kaXN0L3VzZS1tZXJnZS1yZWZzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiAgICAgICAgICAgICAgICAgICAgUGFwZXIgU2hhZGVycyAgICAgICAgICAgICAgICAgICAgKlxuICogICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3BhcGVyLWRlc2lnbi9zaGFkZXJzICAgICAgICpcbiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHVzZU1lcmdlUmVmcyhyZWZzKSB7XG4gIGNvbnN0IGNsZWFudXBSZWYgPSBSZWFjdC51c2VSZWYodm9pZCAwKTtcbiAgY29uc3QgcmVmRWZmZWN0ID0gUmVhY3QudXNlQ2FsbGJhY2soKGluc3RhbmNlKSA9PiB7XG4gICAgY29uc3QgY2xlYW51cHMgPSByZWZzLm1hcCgocmVmKSA9PiB7XG4gICAgICBpZiAocmVmID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiByZWYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCByZWZDYWxsYmFjayA9IHJlZjtcbiAgICAgICAgY29uc3QgcmVmQ2xlYW51cCA9IHJlZkNhbGxiYWNrKGluc3RhbmNlKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiByZWZDbGVhbnVwID09PSBcImZ1bmN0aW9uXCIgPyByZWZDbGVhbnVwIDogKCkgPT4ge1xuICAgICAgICAgIHJlZkNhbGxiYWNrKG51bGwpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmVmLmN1cnJlbnQgPSBpbnN0YW5jZTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNsZWFudXBzLmZvckVhY2goKHJlZkNsZWFudXApID0+IHJlZkNsZWFudXA/LigpKTtcbiAgICB9O1xuICB9LCByZWZzKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmIChyZWZzLmV2ZXJ5KChyZWYpID0+IHJlZiA9PSBudWxsKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAodmFsdWUpID0+IHtcbiAgICAgIGlmIChjbGVhbnVwUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY2xlYW51cFJlZi5jdXJyZW50KCk7XG4gICAgICAgIGNsZWFudXBSZWYuY3VycmVudCA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGNsZWFudXBSZWYuY3VycmVudCA9IHJlZkVmZmVjdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgcmVmcyk7XG59XG5leHBvcnQge1xuICB1c2VNZXJnZVJlZnNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtbWVyZ2UtcmVmcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders-react/dist/use-merge-refs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/get-empty-pixel.js":
/*!********************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/get-empty-pixel.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getEmptyPixel: () => (/* binding */ getEmptyPixel)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nfunction getEmptyPixel() {\n  if (typeof window === \"undefined\") {\n    console.warn(\"Paper Shaders: can\\u2019t create an image on the server\");\n    return void 0;\n  }\n  const img = new Image();\n  img.src = emptyPixel;\n  return img;\n}\nconst emptyPixel = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n\n//# sourceMappingURL=get-empty-pixel.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3QvZ2V0LWVtcHR5LXBpeGVsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFHakM7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2FydHRpY2ZveC9EZXNrdG9wL1dvcmsvcGhvdG9hcHAvbm9kZV9tb2R1bGVzL0BwYXBlci1kZXNpZ24vc2hhZGVycy9kaXN0L2dldC1lbXB0eS1waXhlbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogICAgICAgICAgICAgICAgICAgIFBhcGVyIFNoYWRlcnMgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXBlci1kZXNpZ24vc2hhZGVycyAgICAgICAqXG4gKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKi9cblxuZnVuY3Rpb24gZ2V0RW1wdHlQaXhlbCgpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBjb25zb2xlLndhcm4oXCJQYXBlciBTaGFkZXJzOiBjYW5cXHUyMDE5dCBjcmVhdGUgYW4gaW1hZ2Ugb24gdGhlIHNlcnZlclwiKTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICBpbWcuc3JjID0gZW1wdHlQaXhlbDtcbiAgcmV0dXJuIGltZztcbn1cbmNvbnN0IGVtcHR5UGl4ZWwgPSBcImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBQUFBQUNINUJBRUtBQUVBTEFBQUFBQUJBQUVBQUFJQ1RBRUFPdz09XCI7XG5leHBvcnQge1xuICBnZXRFbXB0eVBpeGVsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LWVtcHR5LXBpeGVsLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/get-empty-pixel.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/get-shader-color-from-string.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/get-shader-color-from-string.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   getShaderColorFromString: () => (/* binding */ getShaderColorFromString)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nfunction getShaderColorFromString(colorString) {\n  if (Array.isArray(colorString)) {\n    if (colorString.length === 4) return colorString;\n    if (colorString.length === 3) return [...colorString, 1];\n    return fallbackColor;\n  }\n  if (typeof colorString !== \"string\") {\n    return fallbackColor;\n  }\n  let r, g, b, a = 1;\n  if (colorString.startsWith(\"#\")) {\n    [r, g, b, a] = hexToRgba(colorString);\n  } else if (colorString.startsWith(\"rgb\")) {\n    [r, g, b, a] = parseRgba(colorString);\n  } else if (colorString.startsWith(\"hsl\")) {\n    [r, g, b, a] = hslaToRgba(parseHsla(colorString));\n  } else {\n    console.error(\"Unsupported color format\", colorString);\n    return fallbackColor;\n  }\n  return [clamp(r, 0, 1), clamp(g, 0, 1), clamp(b, 0, 1), clamp(a, 0, 1)];\n}\nfunction hexToRgba(hex) {\n  hex = hex.replace(/^#/, \"\");\n  if (hex.length === 3) {\n    hex = hex.split(\"\").map((char) => char + char).join(\"\");\n  }\n  if (hex.length === 6) {\n    hex = hex + \"ff\";\n  }\n  const r = parseInt(hex.slice(0, 2), 16) / 255;\n  const g = parseInt(hex.slice(2, 4), 16) / 255;\n  const b = parseInt(hex.slice(4, 6), 16) / 255;\n  const a = parseInt(hex.slice(6, 8), 16) / 255;\n  return [r, g, b, a];\n}\nfunction parseRgba(rgba) {\n  const match = rgba.match(/^rgba?\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*([0-9.]+))?\\s*\\)$/i);\n  if (!match) return [0, 0, 0, 1];\n  return [\n    parseInt(match[1] ?? \"0\") / 255,\n    parseInt(match[2] ?? \"0\") / 255,\n    parseInt(match[3] ?? \"0\") / 255,\n    match[4] === void 0 ? 1 : parseFloat(match[4])\n  ];\n}\nfunction parseHsla(hsla) {\n  const match = hsla.match(/^hsla?\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*(?:,\\s*([0-9.]+))?\\s*\\)$/i);\n  if (!match) return [0, 0, 0, 1];\n  return [\n    parseInt(match[1] ?? \"0\"),\n    parseInt(match[2] ?? \"0\"),\n    parseInt(match[3] ?? \"0\"),\n    match[4] === void 0 ? 1 : parseFloat(match[4])\n  ];\n}\nfunction hslaToRgba(hsla) {\n  const [h, s, l, a] = hsla;\n  const hDecimal = h / 360;\n  const sDecimal = s / 100;\n  const lDecimal = l / 100;\n  let r, g, b;\n  if (s === 0) {\n    r = g = b = lDecimal;\n  } else {\n    const hue2rgb = (p2, q2, t) => {\n      if (t < 0) t += 1;\n      if (t > 1) t -= 1;\n      if (t < 1 / 6) return p2 + (q2 - p2) * 6 * t;\n      if (t < 1 / 2) return q2;\n      if (t < 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;\n      return p2;\n    };\n    const q = lDecimal < 0.5 ? lDecimal * (1 + sDecimal) : lDecimal + sDecimal - lDecimal * sDecimal;\n    const p = 2 * lDecimal - q;\n    r = hue2rgb(p, q, hDecimal + 1 / 3);\n    g = hue2rgb(p, q, hDecimal);\n    b = hue2rgb(p, q, hDecimal - 1 / 3);\n  }\n  return [r, g, b, a];\n}\nconst clamp = (n, min, max) => Math.min(Math.max(n, min), max);\nconst fallbackColor = [0, 0, 0, 1];\n\n//# sourceMappingURL=get-shader-color-from-string.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3QvZ2V0LXNoYWRlci1jb2xvci1mcm9tLXN0cmluZy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcnR0aWNmb3gvRGVza3RvcC9Xb3JrL3Bob3RvYXBwL25vZGVfbW9kdWxlcy9AcGFwZXItZGVzaWduL3NoYWRlcnMvZGlzdC9nZXQtc2hhZGVyLWNvbG9yLWZyb20tc3RyaW5nLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiAgICAgICAgICAgICAgICAgICAgUGFwZXIgU2hhZGVycyAgICAgICAgICAgICAgICAgICAgKlxuICogICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3BhcGVyLWRlc2lnbi9zaGFkZXJzICAgICAgICpcbiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuXG5mdW5jdGlvbiBnZXRTaGFkZXJDb2xvckZyb21TdHJpbmcoY29sb3JTdHJpbmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY29sb3JTdHJpbmcpKSB7XG4gICAgaWYgKGNvbG9yU3RyaW5nLmxlbmd0aCA9PT0gNCkgcmV0dXJuIGNvbG9yU3RyaW5nO1xuICAgIGlmIChjb2xvclN0cmluZy5sZW5ndGggPT09IDMpIHJldHVybiBbLi4uY29sb3JTdHJpbmcsIDFdO1xuICAgIHJldHVybiBmYWxsYmFja0NvbG9yO1xuICB9XG4gIGlmICh0eXBlb2YgY29sb3JTdHJpbmcgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZmFsbGJhY2tDb2xvcjtcbiAgfVxuICBsZXQgciwgZywgYiwgYSA9IDE7XG4gIGlmIChjb2xvclN0cmluZy5zdGFydHNXaXRoKFwiI1wiKSkge1xuICAgIFtyLCBnLCBiLCBhXSA9IGhleFRvUmdiYShjb2xvclN0cmluZyk7XG4gIH0gZWxzZSBpZiAoY29sb3JTdHJpbmcuc3RhcnRzV2l0aChcInJnYlwiKSkge1xuICAgIFtyLCBnLCBiLCBhXSA9IHBhcnNlUmdiYShjb2xvclN0cmluZyk7XG4gIH0gZWxzZSBpZiAoY29sb3JTdHJpbmcuc3RhcnRzV2l0aChcImhzbFwiKSkge1xuICAgIFtyLCBnLCBiLCBhXSA9IGhzbGFUb1JnYmEocGFyc2VIc2xhKGNvbG9yU3RyaW5nKSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5lcnJvcihcIlVuc3VwcG9ydGVkIGNvbG9yIGZvcm1hdFwiLCBjb2xvclN0cmluZyk7XG4gICAgcmV0dXJuIGZhbGxiYWNrQ29sb3I7XG4gIH1cbiAgcmV0dXJuIFtjbGFtcChyLCAwLCAxKSwgY2xhbXAoZywgMCwgMSksIGNsYW1wKGIsIDAsIDEpLCBjbGFtcChhLCAwLCAxKV07XG59XG5mdW5jdGlvbiBoZXhUb1JnYmEoaGV4KSB7XG4gIGhleCA9IGhleC5yZXBsYWNlKC9eIy8sIFwiXCIpO1xuICBpZiAoaGV4Lmxlbmd0aCA9PT0gMykge1xuICAgIGhleCA9IGhleC5zcGxpdChcIlwiKS5tYXAoKGNoYXIpID0+IGNoYXIgKyBjaGFyKS5qb2luKFwiXCIpO1xuICB9XG4gIGlmIChoZXgubGVuZ3RoID09PSA2KSB7XG4gICAgaGV4ID0gaGV4ICsgXCJmZlwiO1xuICB9XG4gIGNvbnN0IHIgPSBwYXJzZUludChoZXguc2xpY2UoMCwgMiksIDE2KSAvIDI1NTtcbiAgY29uc3QgZyA9IHBhcnNlSW50KGhleC5zbGljZSgyLCA0KSwgMTYpIC8gMjU1O1xuICBjb25zdCBiID0gcGFyc2VJbnQoaGV4LnNsaWNlKDQsIDYpLCAxNikgLyAyNTU7XG4gIGNvbnN0IGEgPSBwYXJzZUludChoZXguc2xpY2UoNiwgOCksIDE2KSAvIDI1NTtcbiAgcmV0dXJuIFtyLCBnLCBiLCBhXTtcbn1cbmZ1bmN0aW9uIHBhcnNlUmdiYShyZ2JhKSB7XG4gIGNvbnN0IG1hdGNoID0gcmdiYS5tYXRjaCgvXnJnYmE/XFxzKlxcKFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqKD86LFxccyooWzAtOS5dKykpP1xccypcXCkkL2kpO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gWzAsIDAsIDAsIDFdO1xuICByZXR1cm4gW1xuICAgIHBhcnNlSW50KG1hdGNoWzFdID8/IFwiMFwiKSAvIDI1NSxcbiAgICBwYXJzZUludChtYXRjaFsyXSA/PyBcIjBcIikgLyAyNTUsXG4gICAgcGFyc2VJbnQobWF0Y2hbM10gPz8gXCIwXCIpIC8gMjU1LFxuICAgIG1hdGNoWzRdID09PSB2b2lkIDAgPyAxIDogcGFyc2VGbG9hdChtYXRjaFs0XSlcbiAgXTtcbn1cbmZ1bmN0aW9uIHBhcnNlSHNsYShoc2xhKSB7XG4gIGNvbnN0IG1hdGNoID0gaHNsYS5tYXRjaCgvXmhzbGE/XFxzKlxcKFxccyooXFxkKylcXHMqLFxccyooXFxkKyklXFxzKixcXHMqKFxcZCspJVxccyooPzosXFxzKihbMC05Ll0rKSk/XFxzKlxcKSQvaSk7XG4gIGlmICghbWF0Y2gpIHJldHVybiBbMCwgMCwgMCwgMV07XG4gIHJldHVybiBbXG4gICAgcGFyc2VJbnQobWF0Y2hbMV0gPz8gXCIwXCIpLFxuICAgIHBhcnNlSW50KG1hdGNoWzJdID8/IFwiMFwiKSxcbiAgICBwYXJzZUludChtYXRjaFszXSA/PyBcIjBcIiksXG4gICAgbWF0Y2hbNF0gPT09IHZvaWQgMCA/IDEgOiBwYXJzZUZsb2F0KG1hdGNoWzRdKVxuICBdO1xufVxuZnVuY3Rpb24gaHNsYVRvUmdiYShoc2xhKSB7XG4gIGNvbnN0IFtoLCBzLCBsLCBhXSA9IGhzbGE7XG4gIGNvbnN0IGhEZWNpbWFsID0gaCAvIDM2MDtcbiAgY29uc3Qgc0RlY2ltYWwgPSBzIC8gMTAwO1xuICBjb25zdCBsRGVjaW1hbCA9IGwgLyAxMDA7XG4gIGxldCByLCBnLCBiO1xuICBpZiAocyA9PT0gMCkge1xuICAgIHIgPSBnID0gYiA9IGxEZWNpbWFsO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGh1ZTJyZ2IgPSAocDIsIHEyLCB0KSA9PiB7XG4gICAgICBpZiAodCA8IDApIHQgKz0gMTtcbiAgICAgIGlmICh0ID4gMSkgdCAtPSAxO1xuICAgICAgaWYgKHQgPCAxIC8gNikgcmV0dXJuIHAyICsgKHEyIC0gcDIpICogNiAqIHQ7XG4gICAgICBpZiAodCA8IDEgLyAyKSByZXR1cm4gcTI7XG4gICAgICBpZiAodCA8IDIgLyAzKSByZXR1cm4gcDIgKyAocTIgLSBwMikgKiAoMiAvIDMgLSB0KSAqIDY7XG4gICAgICByZXR1cm4gcDI7XG4gICAgfTtcbiAgICBjb25zdCBxID0gbERlY2ltYWwgPCAwLjUgPyBsRGVjaW1hbCAqICgxICsgc0RlY2ltYWwpIDogbERlY2ltYWwgKyBzRGVjaW1hbCAtIGxEZWNpbWFsICogc0RlY2ltYWw7XG4gICAgY29uc3QgcCA9IDIgKiBsRGVjaW1hbCAtIHE7XG4gICAgciA9IGh1ZTJyZ2IocCwgcSwgaERlY2ltYWwgKyAxIC8gMyk7XG4gICAgZyA9IGh1ZTJyZ2IocCwgcSwgaERlY2ltYWwpO1xuICAgIGIgPSBodWUycmdiKHAsIHEsIGhEZWNpbWFsIC0gMSAvIDMpO1xuICB9XG4gIHJldHVybiBbciwgZywgYiwgYV07XG59XG5jb25zdCBjbGFtcCA9IChuLCBtaW4sIG1heCkgPT4gTWF0aC5taW4oTWF0aC5tYXgobiwgbWluKSwgbWF4KTtcbmNvbnN0IGZhbGxiYWNrQ29sb3IgPSBbMCwgMCwgMCwgMV07XG5leHBvcnQge1xuICBjbGFtcCxcbiAgZ2V0U2hhZGVyQ29sb3JGcm9tU3RyaW5nXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LXNoYWRlci1jb2xvci1mcm9tLXN0cmluZy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/get-shader-color-from-string.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/shader-mount.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/shader-mount.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShaderMount: () => (/* binding */ ShaderMount),\n/* harmony export */   isPaperShaderElement: () => (/* binding */ isPaperShaderElement)\n/* harmony export */ });\n/* harmony import */ var _vertex_shader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vertex-shader.js */ \"(ssr)/./node_modules/@paper-design/shaders/dist/vertex-shader.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\nconst DEFAULT_MAX_PIXEL_COUNT = 1920 * 1080 * 4;\nclass ShaderMount {\n  parentElement;\n  canvasElement;\n  gl;\n  program = null;\n  uniformLocations = {};\n  /** The fragment shader that we are using */\n  fragmentShader;\n  /** Stores the RAF for the render loop */\n  rafId = null;\n  /** Time of the last rendered frame */\n  lastRenderTime = 0;\n  /** Total time that we have played any animation, passed as a uniform to the shader for time-based VFX */\n  currentFrame = 0;\n  /** The speed that we progress through animation time (multiplies by delta time every update). Allows negatives to play in reverse. If set to 0, rAF will stop entirely so static shaders have no recurring performance costs */\n  speed = 0;\n  /** Actual speed used that accounts for document visibility (we pause the shader if the tab is hidden) */\n  currentSpeed = 0;\n  /** Uniforms that are provided by the user for the specific shader being mounted (not including uniforms that this Mount adds, like time and resolution) */\n  providedUniforms;\n  /** Just a sanity check to make sure frames don't run after we're disposed */\n  hasBeenDisposed = false;\n  /** If the resolution of the canvas has changed since the last render */\n  resolutionChanged = true;\n  /** Store textures that are provided by the user */\n  textures = /* @__PURE__ */ new Map();\n  minPixelRatio;\n  maxPixelCount;\n  isSafari = isSafari();\n  uniformCache = {};\n  textureUnitMap = /* @__PURE__ */ new Map();\n  constructor(parentElement, fragmentShader, uniforms, webGlContextAttributes, speed = 0, frame = 0, minPixelRatio = 2, maxPixelCount = DEFAULT_MAX_PIXEL_COUNT) {\n    if (parentElement instanceof HTMLElement) {\n      this.parentElement = parentElement;\n    } else {\n      throw new Error(\"Paper Shaders: parent element must be an HTMLElement\");\n    }\n    if (!document.querySelector(\"style[data-paper-shader]\")) {\n      const styleElement = document.createElement(\"style\");\n      styleElement.innerHTML = defaultStyle;\n      styleElement.setAttribute(\"data-paper-shader\", \"\");\n      document.head.prepend(styleElement);\n    }\n    const canvasElement = document.createElement(\"canvas\");\n    this.canvasElement = canvasElement;\n    this.parentElement.prepend(canvasElement);\n    this.fragmentShader = fragmentShader;\n    this.providedUniforms = uniforms;\n    this.currentFrame = frame;\n    this.minPixelRatio = minPixelRatio;\n    this.maxPixelCount = maxPixelCount;\n    const gl = canvasElement.getContext(\"webgl2\", webGlContextAttributes);\n    if (!gl) {\n      throw new Error(\"Paper Shaders: WebGL is not supported in this browser\");\n    }\n    this.gl = gl;\n    this.initProgram();\n    this.setupPositionAttribute();\n    this.setupUniforms();\n    this.setUniformValues(this.providedUniforms);\n    this.setupResizeObserver();\n    visualViewport?.addEventListener(\"resize\", this.handleVisualViewportChange);\n    this.setSpeed(speed);\n    this.parentElement.setAttribute(\"data-paper-shader\", \"\");\n    this.parentElement.paperShaderMount = this;\n    document.addEventListener(\"visibilitychange\", this.handleDocumentVisibilityChange);\n  }\n  initProgram = () => {\n    const program = createProgram(this.gl, _vertex_shader_js__WEBPACK_IMPORTED_MODULE_0__.vertexShaderSource, this.fragmentShader);\n    if (!program) return;\n    this.program = program;\n  };\n  setupPositionAttribute = () => {\n    const positionAttributeLocation = this.gl.getAttribLocation(this.program, \"a_position\");\n    const positionBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, positionBuffer);\n    const positions = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(positions), this.gl.STATIC_DRAW);\n    this.gl.enableVertexAttribArray(positionAttributeLocation);\n    this.gl.vertexAttribPointer(positionAttributeLocation, 2, this.gl.FLOAT, false, 0, 0);\n  };\n  setupUniforms = () => {\n    const uniformLocations = {\n      u_time: this.gl.getUniformLocation(this.program, \"u_time\"),\n      u_pixelRatio: this.gl.getUniformLocation(this.program, \"u_pixelRatio\"),\n      u_resolution: this.gl.getUniformLocation(this.program, \"u_resolution\")\n    };\n    Object.entries(this.providedUniforms).forEach(([key, value]) => {\n      uniformLocations[key] = this.gl.getUniformLocation(this.program, key);\n      if (value instanceof HTMLImageElement) {\n        const aspectRatioUniformName = `${key}AspectRatio`;\n        uniformLocations[aspectRatioUniformName] = this.gl.getUniformLocation(this.program, aspectRatioUniformName);\n      }\n    });\n    this.uniformLocations = uniformLocations;\n  };\n  /**\n   * The scale that we should render at.\n   * - Used to target 2x rendering even on 1x screens for better antialiasing\n   * - Prevents the virtual resolution from going beyond the maximum resolution\n   * - Accounts for the page zoom level so we render in physical device pixels rather than CSS pixels\n   */\n  renderScale = 1;\n  parentWidth = 0;\n  parentHeight = 0;\n  parentDevicePixelWidth = 0;\n  parentDevicePixelHeight = 0;\n  devicePixelsSupported = false;\n  resizeObserver = null;\n  setupResizeObserver = () => {\n    this.resizeObserver = new ResizeObserver(([entry]) => {\n      if (entry?.borderBoxSize[0]) {\n        const physicalPixelSize = entry.devicePixelContentBoxSize?.[0];\n        if (physicalPixelSize !== void 0) {\n          this.devicePixelsSupported = true;\n          this.parentDevicePixelWidth = physicalPixelSize.inlineSize;\n          this.parentDevicePixelHeight = physicalPixelSize.blockSize;\n        }\n        this.parentWidth = entry.borderBoxSize[0].inlineSize;\n        this.parentHeight = entry.borderBoxSize[0].blockSize;\n      }\n      this.handleResize();\n    });\n    this.resizeObserver.observe(this.parentElement);\n  };\n  // Visual viewport resize handler, mainly used to react to browser zoom changes.\n  // Resize observer by itself does not react to pinch zoom, and although it usually\n  // reacts to classic browser zoom, it's not guaranteed in edge cases.\n  // Since timing between visual viewport changes and resize observer is complex\n  // and because we'd like to know the device pixel sizes of elements, we just restart\n  // the observer to get a guaranteed fresh callback regardless if it would have triggered or not.\n  handleVisualViewportChange = () => {\n    this.resizeObserver?.disconnect();\n    this.setupResizeObserver();\n  };\n  /** Resize handler for when the container div changes size or the max pixel count changes and we want to resize our canvas to match */\n  handleResize = () => {\n    let targetPixelWidth = 0;\n    let targetPixelHeight = 0;\n    const dpr = Math.max(1, window.devicePixelRatio);\n    const pinchZoom = visualViewport?.scale ?? 1;\n    if (this.devicePixelsSupported) {\n      const scaleToMeetMinPixelRatio = Math.max(1, this.minPixelRatio / dpr);\n      targetPixelWidth = this.parentDevicePixelWidth * scaleToMeetMinPixelRatio * pinchZoom;\n      targetPixelHeight = this.parentDevicePixelHeight * scaleToMeetMinPixelRatio * pinchZoom;\n    } else {\n      let targetRenderScale = Math.max(dpr, this.minPixelRatio) * pinchZoom;\n      if (this.isSafari) {\n        const zoomLevel = bestGuessBrowserZoom();\n        targetRenderScale *= Math.max(1, zoomLevel);\n      }\n      targetPixelWidth = Math.round(this.parentWidth) * targetRenderScale;\n      targetPixelHeight = Math.round(this.parentHeight) * targetRenderScale;\n    }\n    const maxPixelCountHeadroom = Math.sqrt(this.maxPixelCount) / Math.sqrt(targetPixelWidth * targetPixelHeight);\n    const scaleToMeetMaxPixelCount = Math.min(1, maxPixelCountHeadroom);\n    const newWidth = Math.round(targetPixelWidth * scaleToMeetMaxPixelCount);\n    const newHeight = Math.round(targetPixelHeight * scaleToMeetMaxPixelCount);\n    const newRenderScale = newWidth / Math.round(this.parentWidth);\n    if (this.canvasElement.width !== newWidth || this.canvasElement.height !== newHeight || this.renderScale !== newRenderScale) {\n      this.renderScale = newRenderScale;\n      this.canvasElement.width = newWidth;\n      this.canvasElement.height = newHeight;\n      this.resolutionChanged = true;\n      this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);\n      this.render(performance.now());\n    }\n  };\n  render = (currentTime) => {\n    if (this.hasBeenDisposed) return;\n    if (this.program === null) {\n      console.warn(\"Tried to render before program or gl was initialized\");\n      return;\n    }\n    const dt = currentTime - this.lastRenderTime;\n    this.lastRenderTime = currentTime;\n    if (this.currentSpeed !== 0) {\n      this.currentFrame += dt * this.currentSpeed;\n    }\n    this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n    this.gl.useProgram(this.program);\n    this.gl.uniform1f(this.uniformLocations.u_time, this.currentFrame * 1e-3);\n    if (this.resolutionChanged) {\n      this.gl.uniform2f(this.uniformLocations.u_resolution, this.gl.canvas.width, this.gl.canvas.height);\n      this.gl.uniform1f(this.uniformLocations.u_pixelRatio, this.renderScale);\n      this.resolutionChanged = false;\n    }\n    this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);\n    if (this.currentSpeed !== 0) {\n      this.requestRender();\n    } else {\n      this.rafId = null;\n    }\n  };\n  requestRender = () => {\n    if (this.rafId !== null) {\n      cancelAnimationFrame(this.rafId);\n    }\n    this.rafId = requestAnimationFrame(this.render);\n  };\n  /** Creates a texture from an image and sets it into a uniform value */\n  setTextureUniform = (uniformName, image) => {\n    if (!image.complete || image.naturalWidth === 0) {\n      throw new Error(`Paper Shaders: image for uniform ${uniformName} must be fully loaded`);\n    }\n    const existingTexture = this.textures.get(uniformName);\n    if (existingTexture) {\n      this.gl.deleteTexture(existingTexture);\n    }\n    if (!this.textureUnitMap.has(uniformName)) {\n      this.textureUnitMap.set(uniformName, this.textureUnitMap.size);\n    }\n    const textureUnit = this.textureUnitMap.get(uniformName);\n    this.gl.activeTexture(this.gl.TEXTURE0 + textureUnit);\n    const texture = this.gl.createTexture();\n    this.gl.bindTexture(this.gl.TEXTURE_2D, texture);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);\n    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);\n    if (uniformName !== \"u_noiseTexture\") {\n      this.gl.generateMipmap(this.gl.TEXTURE_2D);\n      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR_MIPMAP_LINEAR);\n    }\n    const error = this.gl.getError();\n    if (error !== this.gl.NO_ERROR || texture === null) {\n      console.error(\"Paper Shaders: WebGL error when uploading texture:\", error);\n      return;\n    }\n    this.textures.set(uniformName, texture);\n    const location = this.uniformLocations[uniformName];\n    if (location) {\n      this.gl.uniform1i(location, textureUnit);\n      const aspectRatioUniformName = `${uniformName}AspectRatio`;\n      const aspectRatioLocation = this.uniformLocations[aspectRatioUniformName];\n      if (aspectRatioLocation) {\n        const aspectRatio = image.naturalWidth / image.naturalHeight;\n        this.gl.uniform1f(aspectRatioLocation, aspectRatio);\n      }\n    }\n  };\n  /** Utility: recursive equality test for all the uniforms */\n  areUniformValuesEqual = (a, b) => {\n    if (a === b) return true;\n    if (Array.isArray(a) && Array.isArray(b) && a.length === b.length) {\n      return a.every((val, i) => this.areUniformValuesEqual(val, b[i]));\n    }\n    return false;\n  };\n  /** Sets the provided uniform values into the WebGL program, can be a partial list of uniforms that have changed */\n  setUniformValues = (updatedUniforms) => {\n    this.gl.useProgram(this.program);\n    Object.entries(updatedUniforms).forEach(([key, value]) => {\n      let cacheValue = value;\n      if (value instanceof HTMLImageElement) {\n        cacheValue = `${value.src.slice(0, 200)}|${value.naturalWidth}x${value.naturalHeight}`;\n      }\n      if (this.areUniformValuesEqual(this.uniformCache[key], cacheValue)) return;\n      this.uniformCache[key] = cacheValue;\n      const location = this.uniformLocations[key];\n      if (!location) {\n        console.warn(`Uniform location for ${key} not found`);\n        return;\n      }\n      if (value instanceof HTMLImageElement) {\n        this.setTextureUniform(key, value);\n      } else if (Array.isArray(value)) {\n        let flatArray = null;\n        let valueLength = null;\n        if (value[0] !== void 0 && Array.isArray(value[0])) {\n          const firstChildLength = value[0].length;\n          if (value.every((arr) => arr.length === firstChildLength)) {\n            flatArray = value.flat();\n            valueLength = firstChildLength;\n          } else {\n            console.warn(`All child arrays must be the same length for ${key}`);\n            return;\n          }\n        } else {\n          flatArray = value;\n          valueLength = flatArray.length;\n        }\n        switch (valueLength) {\n          case 2:\n            this.gl.uniform2fv(location, flatArray);\n            break;\n          case 3:\n            this.gl.uniform3fv(location, flatArray);\n            break;\n          case 4:\n            this.gl.uniform4fv(location, flatArray);\n            break;\n          case 9:\n            this.gl.uniformMatrix3fv(location, false, flatArray);\n            break;\n          case 16:\n            this.gl.uniformMatrix4fv(location, false, flatArray);\n            break;\n          default:\n            console.warn(`Unsupported uniform array length: ${valueLength}`);\n        }\n      } else if (typeof value === \"number\") {\n        this.gl.uniform1f(location, value);\n      } else if (typeof value === \"boolean\") {\n        this.gl.uniform1i(location, value ? 1 : 0);\n      } else {\n        console.warn(`Unsupported uniform type for ${key}: ${typeof value}`);\n      }\n    });\n  };\n  /** Gets the current total animation time from 0ms */\n  getCurrentFrame = () => {\n    return this.currentFrame;\n  };\n  /** Set a frame to get a deterministic result, frames are literally just milliseconds from zero since the animation started */\n  setFrame = (newFrame) => {\n    this.currentFrame = newFrame;\n    this.lastRenderTime = performance.now();\n    this.render(performance.now());\n  };\n  /** Set an animation speed (or 0 to stop animation) */\n  setSpeed = (newSpeed = 1) => {\n    this.speed = newSpeed;\n    this.setCurrentSpeed(document.hidden ? 0 : newSpeed);\n  };\n  setCurrentSpeed = (newSpeed) => {\n    this.currentSpeed = newSpeed;\n    if (this.rafId === null && newSpeed !== 0) {\n      this.lastRenderTime = performance.now();\n      this.rafId = requestAnimationFrame(this.render);\n    }\n    if (this.rafId !== null && newSpeed === 0) {\n      cancelAnimationFrame(this.rafId);\n      this.rafId = null;\n    }\n  };\n  /** Set the maximum pixel count for the shader, this will limit the number of pixels that will be rendered */\n  setMaxPixelCount = (newMaxPixelCount = DEFAULT_MAX_PIXEL_COUNT) => {\n    this.maxPixelCount = newMaxPixelCount;\n    this.handleResize();\n  };\n  /** Set the minimum pixel ratio for the shader */\n  setMinPixelRatio = (newMinPixelRatio = 2) => {\n    this.minPixelRatio = newMinPixelRatio;\n    this.handleResize();\n  };\n  /** Update the uniforms that are provided by the outside shader, can be a partial set with only the uniforms that have changed */\n  setUniforms = (newUniforms) => {\n    this.setUniformValues(newUniforms);\n    this.providedUniforms = { ...this.providedUniforms, ...newUniforms };\n    this.render(performance.now());\n  };\n  handleDocumentVisibilityChange = () => {\n    this.setCurrentSpeed(document.hidden ? 0 : this.speed);\n  };\n  /** Dispose of the shader mount, cleaning up all of the WebGL resources */\n  dispose = () => {\n    this.hasBeenDisposed = true;\n    if (this.rafId !== null) {\n      cancelAnimationFrame(this.rafId);\n      this.rafId = null;\n    }\n    if (this.gl && this.program) {\n      this.textures.forEach((texture) => {\n        this.gl.deleteTexture(texture);\n      });\n      this.textures.clear();\n      this.gl.deleteProgram(this.program);\n      this.program = null;\n      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n      this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, null);\n      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);\n      this.gl.getError();\n    }\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n      this.resizeObserver = null;\n    }\n    visualViewport?.removeEventListener(\"resize\", this.handleVisualViewportChange);\n    document.removeEventListener(\"visibilitychange\", this.handleDocumentVisibilityChange);\n    this.uniformLocations = {};\n    this.canvasElement.remove();\n    delete this.parentElement.paperShaderMount;\n  };\n}\nfunction createShader(gl, type, source) {\n  const shader = gl.createShader(type);\n  if (!shader) return null;\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    console.error(\"An error occurred compiling the shaders: \" + gl.getShaderInfoLog(shader));\n    gl.deleteShader(shader);\n    return null;\n  }\n  return shader;\n}\nfunction createProgram(gl, vertexShaderSource2, fragmentShaderSource) {\n  const format = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT);\n  const precision = format ? format.precision : null;\n  if (precision && precision < 23) {\n    vertexShaderSource2 = vertexShaderSource2.replace(/precision\\s+(lowp|mediump)\\s+float;/g, \"precision highp float;\");\n    fragmentShaderSource = fragmentShaderSource.replace(/precision\\s+(lowp|mediump)\\s+float/g, \"precision highp float\").replace(/\\b(uniform|varying|attribute)\\s+(lowp|mediump)\\s+(\\w+)/g, \"$1 highp $3\");\n  }\n  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource2);\n  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n  if (!vertexShader || !fragmentShader) return null;\n  const program = gl.createProgram();\n  if (!program) return null;\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.error(\"Unable to initialize the shader program: \" + gl.getProgramInfoLog(program));\n    gl.deleteProgram(program);\n    gl.deleteShader(vertexShader);\n    gl.deleteShader(fragmentShader);\n    return null;\n  }\n  gl.detachShader(program, vertexShader);\n  gl.detachShader(program, fragmentShader);\n  gl.deleteShader(vertexShader);\n  gl.deleteShader(fragmentShader);\n  return program;\n}\nconst defaultStyle = `@layer paper-shaders {\n  :where([data-paper-shader]) {\n    isolation: isolate;\n    position: relative;\n\n    & canvas {\n      contain: strict;\n      display: block;\n      position: absolute;\n      inset: 0;\n      z-index: -1;\n      width: 100%;\n      height: 100%;\n      border-radius: inherit;\n      corner-shape: inherit;\n    }\n  }\n}`;\nfunction isPaperShaderElement(element) {\n  return \"paperShaderMount\" in element;\n}\nfunction isSafari() {\n  const ua = navigator.userAgent.toLowerCase();\n  return ua.includes(\"safari\") && !ua.includes(\"chrome\") && !ua.includes(\"android\");\n}\nfunction bestGuessBrowserZoom() {\n  const viewportScale = visualViewport?.scale ?? 1;\n  const viewportWidth = visualViewport?.width ?? window.innerWidth;\n  const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n  const innerWidth = viewportScale * viewportWidth + scrollbarWidth;\n  const ratio = outerWidth / innerWidth;\n  const zoomPercentageRounded = Math.round(100 * ratio);\n  if (zoomPercentageRounded % 5 === 0) {\n    return zoomPercentageRounded / 100;\n  }\n  if (zoomPercentageRounded === 33) {\n    return 1 / 3;\n  }\n  if (zoomPercentageRounded === 67) {\n    return 2 / 3;\n  }\n  if (zoomPercentageRounded === 133) {\n    return 4 / 3;\n  }\n  return ratio;\n}\n\n//# sourceMappingURL=shader-mount.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLW1vdW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUV3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxpRUFBa0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLElBQUk7QUFDOUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxhQUFhO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxZQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0IsR0FBRyxtQkFBbUIsR0FBRyxvQkFBb0I7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxLQUFLO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLHlFQUF5RSxJQUFJO0FBQzdFO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxZQUFZO0FBQzFFO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSLHFEQUFxRCxJQUFJLElBQUksYUFBYTtBQUMxRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLDJCQUEyQjtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2FydHRpY2ZveC9EZXNrdG9wL1dvcmsvcGhvdG9hcHAvbm9kZV9tb2R1bGVzL0BwYXBlci1kZXNpZ24vc2hhZGVycy9kaXN0L3NoYWRlci1tb3VudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogICAgICAgICAgICAgICAgICAgIFBhcGVyIFNoYWRlcnMgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXBlci1kZXNpZ24vc2hhZGVycyAgICAgICAqXG4gKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKi9cblxuaW1wb3J0IHsgdmVydGV4U2hhZGVyU291cmNlIH0gZnJvbSBcIi4vdmVydGV4LXNoYWRlci5qc1wiO1xuY29uc3QgREVGQVVMVF9NQVhfUElYRUxfQ09VTlQgPSAxOTIwICogMTA4MCAqIDQ7XG5jbGFzcyBTaGFkZXJNb3VudCB7XG4gIHBhcmVudEVsZW1lbnQ7XG4gIGNhbnZhc0VsZW1lbnQ7XG4gIGdsO1xuICBwcm9ncmFtID0gbnVsbDtcbiAgdW5pZm9ybUxvY2F0aW9ucyA9IHt9O1xuICAvKiogVGhlIGZyYWdtZW50IHNoYWRlciB0aGF0IHdlIGFyZSB1c2luZyAqL1xuICBmcmFnbWVudFNoYWRlcjtcbiAgLyoqIFN0b3JlcyB0aGUgUkFGIGZvciB0aGUgcmVuZGVyIGxvb3AgKi9cbiAgcmFmSWQgPSBudWxsO1xuICAvKiogVGltZSBvZiB0aGUgbGFzdCByZW5kZXJlZCBmcmFtZSAqL1xuICBsYXN0UmVuZGVyVGltZSA9IDA7XG4gIC8qKiBUb3RhbCB0aW1lIHRoYXQgd2UgaGF2ZSBwbGF5ZWQgYW55IGFuaW1hdGlvbiwgcGFzc2VkIGFzIGEgdW5pZm9ybSB0byB0aGUgc2hhZGVyIGZvciB0aW1lLWJhc2VkIFZGWCAqL1xuICBjdXJyZW50RnJhbWUgPSAwO1xuICAvKiogVGhlIHNwZWVkIHRoYXQgd2UgcHJvZ3Jlc3MgdGhyb3VnaCBhbmltYXRpb24gdGltZSAobXVsdGlwbGllcyBieSBkZWx0YSB0aW1lIGV2ZXJ5IHVwZGF0ZSkuIEFsbG93cyBuZWdhdGl2ZXMgdG8gcGxheSBpbiByZXZlcnNlLiBJZiBzZXQgdG8gMCwgckFGIHdpbGwgc3RvcCBlbnRpcmVseSBzbyBzdGF0aWMgc2hhZGVycyBoYXZlIG5vIHJlY3VycmluZyBwZXJmb3JtYW5jZSBjb3N0cyAqL1xuICBzcGVlZCA9IDA7XG4gIC8qKiBBY3R1YWwgc3BlZWQgdXNlZCB0aGF0IGFjY291bnRzIGZvciBkb2N1bWVudCB2aXNpYmlsaXR5ICh3ZSBwYXVzZSB0aGUgc2hhZGVyIGlmIHRoZSB0YWIgaXMgaGlkZGVuKSAqL1xuICBjdXJyZW50U3BlZWQgPSAwO1xuICAvKiogVW5pZm9ybXMgdGhhdCBhcmUgcHJvdmlkZWQgYnkgdGhlIHVzZXIgZm9yIHRoZSBzcGVjaWZpYyBzaGFkZXIgYmVpbmcgbW91bnRlZCAobm90IGluY2x1ZGluZyB1bmlmb3JtcyB0aGF0IHRoaXMgTW91bnQgYWRkcywgbGlrZSB0aW1lIGFuZCByZXNvbHV0aW9uKSAqL1xuICBwcm92aWRlZFVuaWZvcm1zO1xuICAvKiogSnVzdCBhIHNhbml0eSBjaGVjayB0byBtYWtlIHN1cmUgZnJhbWVzIGRvbid0IHJ1biBhZnRlciB3ZSdyZSBkaXNwb3NlZCAqL1xuICBoYXNCZWVuRGlzcG9zZWQgPSBmYWxzZTtcbiAgLyoqIElmIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBjYW52YXMgaGFzIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgcmVuZGVyICovXG4gIHJlc29sdXRpb25DaGFuZ2VkID0gdHJ1ZTtcbiAgLyoqIFN0b3JlIHRleHR1cmVzIHRoYXQgYXJlIHByb3ZpZGVkIGJ5IHRoZSB1c2VyICovXG4gIHRleHR1cmVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbWluUGl4ZWxSYXRpbztcbiAgbWF4UGl4ZWxDb3VudDtcbiAgaXNTYWZhcmkgPSBpc1NhZmFyaSgpO1xuICB1bmlmb3JtQ2FjaGUgPSB7fTtcbiAgdGV4dHVyZVVuaXRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdHJ1Y3RvcihwYXJlbnRFbGVtZW50LCBmcmFnbWVudFNoYWRlciwgdW5pZm9ybXMsIHdlYkdsQ29udGV4dEF0dHJpYnV0ZXMsIHNwZWVkID0gMCwgZnJhbWUgPSAwLCBtaW5QaXhlbFJhdGlvID0gMiwgbWF4UGl4ZWxDb3VudCA9IERFRkFVTFRfTUFYX1BJWEVMX0NPVU5UKSB7XG4gICAgaWYgKHBhcmVudEVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgdGhpcy5wYXJlbnRFbGVtZW50ID0gcGFyZW50RWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFwZXIgU2hhZGVyczogcGFyZW50IGVsZW1lbnQgbXVzdCBiZSBhbiBIVE1MRWxlbWVudFwiKTtcbiAgICB9XG4gICAgaWYgKCFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwic3R5bGVbZGF0YS1wYXBlci1zaGFkZXJdXCIpKSB7XG4gICAgICBjb25zdCBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICBzdHlsZUVsZW1lbnQuaW5uZXJIVE1MID0gZGVmYXVsdFN0eWxlO1xuICAgICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtcGFwZXItc2hhZGVyXCIsIFwiXCIpO1xuICAgICAgZG9jdW1lbnQuaGVhZC5wcmVwZW5kKHN0eWxlRWxlbWVudCk7XG4gICAgfVxuICAgIGNvbnN0IGNhbnZhc0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIHRoaXMuY2FudmFzRWxlbWVudCA9IGNhbnZhc0VsZW1lbnQ7XG4gICAgdGhpcy5wYXJlbnRFbGVtZW50LnByZXBlbmQoY2FudmFzRWxlbWVudCk7XG4gICAgdGhpcy5mcmFnbWVudFNoYWRlciA9IGZyYWdtZW50U2hhZGVyO1xuICAgIHRoaXMucHJvdmlkZWRVbmlmb3JtcyA9IHVuaWZvcm1zO1xuICAgIHRoaXMuY3VycmVudEZyYW1lID0gZnJhbWU7XG4gICAgdGhpcy5taW5QaXhlbFJhdGlvID0gbWluUGl4ZWxSYXRpbztcbiAgICB0aGlzLm1heFBpeGVsQ291bnQgPSBtYXhQaXhlbENvdW50O1xuICAgIGNvbnN0IGdsID0gY2FudmFzRWxlbWVudC5nZXRDb250ZXh0KFwid2ViZ2wyXCIsIHdlYkdsQ29udGV4dEF0dHJpYnV0ZXMpO1xuICAgIGlmICghZ2wpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcGVyIFNoYWRlcnM6IFdlYkdMIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyXCIpO1xuICAgIH1cbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgdGhpcy5pbml0UHJvZ3JhbSgpO1xuICAgIHRoaXMuc2V0dXBQb3NpdGlvbkF0dHJpYnV0ZSgpO1xuICAgIHRoaXMuc2V0dXBVbmlmb3JtcygpO1xuICAgIHRoaXMuc2V0VW5pZm9ybVZhbHVlcyh0aGlzLnByb3ZpZGVkVW5pZm9ybXMpO1xuICAgIHRoaXMuc2V0dXBSZXNpemVPYnNlcnZlcigpO1xuICAgIHZpc3VhbFZpZXdwb3J0Py5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMuaGFuZGxlVmlzdWFsVmlld3BvcnRDaGFuZ2UpO1xuICAgIHRoaXMuc2V0U3BlZWQoc3BlZWQpO1xuICAgIHRoaXMucGFyZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBhcGVyLXNoYWRlclwiLCBcIlwiKTtcbiAgICB0aGlzLnBhcmVudEVsZW1lbnQucGFwZXJTaGFkZXJNb3VudCA9IHRoaXM7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgdGhpcy5oYW5kbGVEb2N1bWVudFZpc2liaWxpdHlDaGFuZ2UpO1xuICB9XG4gIGluaXRQcm9ncmFtID0gKCkgPT4ge1xuICAgIGNvbnN0IHByb2dyYW0gPSBjcmVhdGVQcm9ncmFtKHRoaXMuZ2wsIHZlcnRleFNoYWRlclNvdXJjZSwgdGhpcy5mcmFnbWVudFNoYWRlcik7XG4gICAgaWYgKCFwcm9ncmFtKSByZXR1cm47XG4gICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcbiAgfTtcbiAgc2V0dXBQb3NpdGlvbkF0dHJpYnV0ZSA9ICgpID0+IHtcbiAgICBjb25zdCBwb3NpdGlvbkF0dHJpYnV0ZUxvY2F0aW9uID0gdGhpcy5nbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLnByb2dyYW0sIFwiYV9wb3NpdGlvblwiKTtcbiAgICBjb25zdCBwb3NpdGlvbkJ1ZmZlciA9IHRoaXMuZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCBwb3NpdGlvbkJ1ZmZlcik7XG4gICAgY29uc3QgcG9zaXRpb25zID0gWy0xLCAtMSwgMSwgLTEsIC0xLCAxLCAtMSwgMSwgMSwgLTEsIDEsIDFdO1xuICAgIHRoaXMuZ2wuYnVmZmVyRGF0YSh0aGlzLmdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbnMpLCB0aGlzLmdsLlNUQVRJQ19EUkFXKTtcbiAgICB0aGlzLmdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uQXR0cmlidXRlTG9jYXRpb24pO1xuICAgIHRoaXMuZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NpdGlvbkF0dHJpYnV0ZUxvY2F0aW9uLCAyLCB0aGlzLmdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gIH07XG4gIHNldHVwVW5pZm9ybXMgPSAoKSA9PiB7XG4gICAgY29uc3QgdW5pZm9ybUxvY2F0aW9ucyA9IHtcbiAgICAgIHVfdGltZTogdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBcInVfdGltZVwiKSxcbiAgICAgIHVfcGl4ZWxSYXRpbzogdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBcInVfcGl4ZWxSYXRpb1wiKSxcbiAgICAgIHVfcmVzb2x1dGlvbjogdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBcInVfcmVzb2x1dGlvblwiKVxuICAgIH07XG4gICAgT2JqZWN0LmVudHJpZXModGhpcy5wcm92aWRlZFVuaWZvcm1zKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIHVuaWZvcm1Mb2NhdGlvbnNba2V5XSA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwga2V5KTtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgYXNwZWN0UmF0aW9Vbmlmb3JtTmFtZSA9IGAke2tleX1Bc3BlY3RSYXRpb2A7XG4gICAgICAgIHVuaWZvcm1Mb2NhdGlvbnNbYXNwZWN0UmF0aW9Vbmlmb3JtTmFtZV0gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIGFzcGVjdFJhdGlvVW5pZm9ybU5hbWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMudW5pZm9ybUxvY2F0aW9ucyA9IHVuaWZvcm1Mb2NhdGlvbnM7XG4gIH07XG4gIC8qKlxuICAgKiBUaGUgc2NhbGUgdGhhdCB3ZSBzaG91bGQgcmVuZGVyIGF0LlxuICAgKiAtIFVzZWQgdG8gdGFyZ2V0IDJ4IHJlbmRlcmluZyBldmVuIG9uIDF4IHNjcmVlbnMgZm9yIGJldHRlciBhbnRpYWxpYXNpbmdcbiAgICogLSBQcmV2ZW50cyB0aGUgdmlydHVhbCByZXNvbHV0aW9uIGZyb20gZ29pbmcgYmV5b25kIHRoZSBtYXhpbXVtIHJlc29sdXRpb25cbiAgICogLSBBY2NvdW50cyBmb3IgdGhlIHBhZ2Ugem9vbSBsZXZlbCBzbyB3ZSByZW5kZXIgaW4gcGh5c2ljYWwgZGV2aWNlIHBpeGVscyByYXRoZXIgdGhhbiBDU1MgcGl4ZWxzXG4gICAqL1xuICByZW5kZXJTY2FsZSA9IDE7XG4gIHBhcmVudFdpZHRoID0gMDtcbiAgcGFyZW50SGVpZ2h0ID0gMDtcbiAgcGFyZW50RGV2aWNlUGl4ZWxXaWR0aCA9IDA7XG4gIHBhcmVudERldmljZVBpeGVsSGVpZ2h0ID0gMDtcbiAgZGV2aWNlUGl4ZWxzU3VwcG9ydGVkID0gZmFsc2U7XG4gIHJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgc2V0dXBSZXNpemVPYnNlcnZlciA9ICgpID0+IHtcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKChbZW50cnldKSA9PiB7XG4gICAgICBpZiAoZW50cnk/LmJvcmRlckJveFNpemVbMF0pIHtcbiAgICAgICAgY29uc3QgcGh5c2ljYWxQaXhlbFNpemUgPSBlbnRyeS5kZXZpY2VQaXhlbENvbnRlbnRCb3hTaXplPy5bMF07XG4gICAgICAgIGlmIChwaHlzaWNhbFBpeGVsU2l6ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhpcy5kZXZpY2VQaXhlbHNTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMucGFyZW50RGV2aWNlUGl4ZWxXaWR0aCA9IHBoeXNpY2FsUGl4ZWxTaXplLmlubGluZVNpemU7XG4gICAgICAgICAgdGhpcy5wYXJlbnREZXZpY2VQaXhlbEhlaWdodCA9IHBoeXNpY2FsUGl4ZWxTaXplLmJsb2NrU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcmVudFdpZHRoID0gZW50cnkuYm9yZGVyQm94U2l6ZVswXS5pbmxpbmVTaXplO1xuICAgICAgICB0aGlzLnBhcmVudEhlaWdodCA9IGVudHJ5LmJvcmRlckJveFNpemVbMF0uYmxvY2tTaXplO1xuICAgICAgfVxuICAgICAgdGhpcy5oYW5kbGVSZXNpemUoKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy5wYXJlbnRFbGVtZW50KTtcbiAgfTtcbiAgLy8gVmlzdWFsIHZpZXdwb3J0IHJlc2l6ZSBoYW5kbGVyLCBtYWlubHkgdXNlZCB0byByZWFjdCB0byBicm93c2VyIHpvb20gY2hhbmdlcy5cbiAgLy8gUmVzaXplIG9ic2VydmVyIGJ5IGl0c2VsZiBkb2VzIG5vdCByZWFjdCB0byBwaW5jaCB6b29tLCBhbmQgYWx0aG91Z2ggaXQgdXN1YWxseVxuICAvLyByZWFjdHMgdG8gY2xhc3NpYyBicm93c2VyIHpvb20sIGl0J3Mgbm90IGd1YXJhbnRlZWQgaW4gZWRnZSBjYXNlcy5cbiAgLy8gU2luY2UgdGltaW5nIGJldHdlZW4gdmlzdWFsIHZpZXdwb3J0IGNoYW5nZXMgYW5kIHJlc2l6ZSBvYnNlcnZlciBpcyBjb21wbGV4XG4gIC8vIGFuZCBiZWNhdXNlIHdlJ2QgbGlrZSB0byBrbm93IHRoZSBkZXZpY2UgcGl4ZWwgc2l6ZXMgb2YgZWxlbWVudHMsIHdlIGp1c3QgcmVzdGFydFxuICAvLyB0aGUgb2JzZXJ2ZXIgdG8gZ2V0IGEgZ3VhcmFudGVlZCBmcmVzaCBjYWxsYmFjayByZWdhcmRsZXNzIGlmIGl0IHdvdWxkIGhhdmUgdHJpZ2dlcmVkIG9yIG5vdC5cbiAgaGFuZGxlVmlzdWFsVmlld3BvcnRDaGFuZ2UgPSAoKSA9PiB7XG4gICAgdGhpcy5yZXNpemVPYnNlcnZlcj8uZGlzY29ubmVjdCgpO1xuICAgIHRoaXMuc2V0dXBSZXNpemVPYnNlcnZlcigpO1xuICB9O1xuICAvKiogUmVzaXplIGhhbmRsZXIgZm9yIHdoZW4gdGhlIGNvbnRhaW5lciBkaXYgY2hhbmdlcyBzaXplIG9yIHRoZSBtYXggcGl4ZWwgY291bnQgY2hhbmdlcyBhbmQgd2Ugd2FudCB0byByZXNpemUgb3VyIGNhbnZhcyB0byBtYXRjaCAqL1xuICBoYW5kbGVSZXNpemUgPSAoKSA9PiB7XG4gICAgbGV0IHRhcmdldFBpeGVsV2lkdGggPSAwO1xuICAgIGxldCB0YXJnZXRQaXhlbEhlaWdodCA9IDA7XG4gICAgY29uc3QgZHByID0gTWF0aC5tYXgoMSwgd2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xuICAgIGNvbnN0IHBpbmNoWm9vbSA9IHZpc3VhbFZpZXdwb3J0Py5zY2FsZSA/PyAxO1xuICAgIGlmICh0aGlzLmRldmljZVBpeGVsc1N1cHBvcnRlZCkge1xuICAgICAgY29uc3Qgc2NhbGVUb01lZXRNaW5QaXhlbFJhdGlvID0gTWF0aC5tYXgoMSwgdGhpcy5taW5QaXhlbFJhdGlvIC8gZHByKTtcbiAgICAgIHRhcmdldFBpeGVsV2lkdGggPSB0aGlzLnBhcmVudERldmljZVBpeGVsV2lkdGggKiBzY2FsZVRvTWVldE1pblBpeGVsUmF0aW8gKiBwaW5jaFpvb207XG4gICAgICB0YXJnZXRQaXhlbEhlaWdodCA9IHRoaXMucGFyZW50RGV2aWNlUGl4ZWxIZWlnaHQgKiBzY2FsZVRvTWVldE1pblBpeGVsUmF0aW8gKiBwaW5jaFpvb207XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB0YXJnZXRSZW5kZXJTY2FsZSA9IE1hdGgubWF4KGRwciwgdGhpcy5taW5QaXhlbFJhdGlvKSAqIHBpbmNoWm9vbTtcbiAgICAgIGlmICh0aGlzLmlzU2FmYXJpKSB7XG4gICAgICAgIGNvbnN0IHpvb21MZXZlbCA9IGJlc3RHdWVzc0Jyb3dzZXJab29tKCk7XG4gICAgICAgIHRhcmdldFJlbmRlclNjYWxlICo9IE1hdGgubWF4KDEsIHpvb21MZXZlbCk7XG4gICAgICB9XG4gICAgICB0YXJnZXRQaXhlbFdpZHRoID0gTWF0aC5yb3VuZCh0aGlzLnBhcmVudFdpZHRoKSAqIHRhcmdldFJlbmRlclNjYWxlO1xuICAgICAgdGFyZ2V0UGl4ZWxIZWlnaHQgPSBNYXRoLnJvdW5kKHRoaXMucGFyZW50SGVpZ2h0KSAqIHRhcmdldFJlbmRlclNjYWxlO1xuICAgIH1cbiAgICBjb25zdCBtYXhQaXhlbENvdW50SGVhZHJvb20gPSBNYXRoLnNxcnQodGhpcy5tYXhQaXhlbENvdW50KSAvIE1hdGguc3FydCh0YXJnZXRQaXhlbFdpZHRoICogdGFyZ2V0UGl4ZWxIZWlnaHQpO1xuICAgIGNvbnN0IHNjYWxlVG9NZWV0TWF4UGl4ZWxDb3VudCA9IE1hdGgubWluKDEsIG1heFBpeGVsQ291bnRIZWFkcm9vbSk7XG4gICAgY29uc3QgbmV3V2lkdGggPSBNYXRoLnJvdW5kKHRhcmdldFBpeGVsV2lkdGggKiBzY2FsZVRvTWVldE1heFBpeGVsQ291bnQpO1xuICAgIGNvbnN0IG5ld0hlaWdodCA9IE1hdGgucm91bmQodGFyZ2V0UGl4ZWxIZWlnaHQgKiBzY2FsZVRvTWVldE1heFBpeGVsQ291bnQpO1xuICAgIGNvbnN0IG5ld1JlbmRlclNjYWxlID0gbmV3V2lkdGggLyBNYXRoLnJvdW5kKHRoaXMucGFyZW50V2lkdGgpO1xuICAgIGlmICh0aGlzLmNhbnZhc0VsZW1lbnQud2lkdGggIT09IG5ld1dpZHRoIHx8IHRoaXMuY2FudmFzRWxlbWVudC5oZWlnaHQgIT09IG5ld0hlaWdodCB8fCB0aGlzLnJlbmRlclNjYWxlICE9PSBuZXdSZW5kZXJTY2FsZSkge1xuICAgICAgdGhpcy5yZW5kZXJTY2FsZSA9IG5ld1JlbmRlclNjYWxlO1xuICAgICAgdGhpcy5jYW52YXNFbGVtZW50LndpZHRoID0gbmV3V2lkdGg7XG4gICAgICB0aGlzLmNhbnZhc0VsZW1lbnQuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgdGhpcy5yZXNvbHV0aW9uQ2hhbmdlZCA9IHRydWU7XG4gICAgICB0aGlzLmdsLnZpZXdwb3J0KDAsIDAsIHRoaXMuZ2wuY2FudmFzLndpZHRoLCB0aGlzLmdsLmNhbnZhcy5oZWlnaHQpO1xuICAgICAgdGhpcy5yZW5kZXIocGVyZm9ybWFuY2Uubm93KCkpO1xuICAgIH1cbiAgfTtcbiAgcmVuZGVyID0gKGN1cnJlbnRUaW1lKSA9PiB7XG4gICAgaWYgKHRoaXMuaGFzQmVlbkRpc3Bvc2VkKSByZXR1cm47XG4gICAgaWYgKHRoaXMucHJvZ3JhbSA9PT0gbnVsbCkge1xuICAgICAgY29uc29sZS53YXJuKFwiVHJpZWQgdG8gcmVuZGVyIGJlZm9yZSBwcm9ncmFtIG9yIGdsIHdhcyBpbml0aWFsaXplZFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZHQgPSBjdXJyZW50VGltZSAtIHRoaXMubGFzdFJlbmRlclRpbWU7XG4gICAgdGhpcy5sYXN0UmVuZGVyVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIGlmICh0aGlzLmN1cnJlbnRTcGVlZCAhPT0gMCkge1xuICAgICAgdGhpcy5jdXJyZW50RnJhbWUgKz0gZHQgKiB0aGlzLmN1cnJlbnRTcGVlZDtcbiAgICB9XG4gICAgdGhpcy5nbC5jbGVhcih0aGlzLmdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgIHRoaXMuZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuICAgIHRoaXMuZ2wudW5pZm9ybTFmKHRoaXMudW5pZm9ybUxvY2F0aW9ucy51X3RpbWUsIHRoaXMuY3VycmVudEZyYW1lICogMWUtMyk7XG4gICAgaWYgKHRoaXMucmVzb2x1dGlvbkNoYW5nZWQpIHtcbiAgICAgIHRoaXMuZ2wudW5pZm9ybTJmKHRoaXMudW5pZm9ybUxvY2F0aW9ucy51X3Jlc29sdXRpb24sIHRoaXMuZ2wuY2FudmFzLndpZHRoLCB0aGlzLmdsLmNhbnZhcy5oZWlnaHQpO1xuICAgICAgdGhpcy5nbC51bmlmb3JtMWYodGhpcy51bmlmb3JtTG9jYXRpb25zLnVfcGl4ZWxSYXRpbywgdGhpcy5yZW5kZXJTY2FsZSk7XG4gICAgICB0aGlzLnJlc29sdXRpb25DaGFuZ2VkID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuZ2wuZHJhd0FycmF5cyh0aGlzLmdsLlRSSUFOR0xFUywgMCwgNik7XG4gICAgaWYgKHRoaXMuY3VycmVudFNwZWVkICE9PSAwKSB7XG4gICAgICB0aGlzLnJlcXVlc3RSZW5kZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yYWZJZCA9IG51bGw7XG4gICAgfVxuICB9O1xuICByZXF1ZXN0UmVuZGVyID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLnJhZklkICE9PSBudWxsKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJhZklkKTtcbiAgICB9XG4gICAgdGhpcy5yYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnJlbmRlcik7XG4gIH07XG4gIC8qKiBDcmVhdGVzIGEgdGV4dHVyZSBmcm9tIGFuIGltYWdlIGFuZCBzZXRzIGl0IGludG8gYSB1bmlmb3JtIHZhbHVlICovXG4gIHNldFRleHR1cmVVbmlmb3JtID0gKHVuaWZvcm1OYW1lLCBpbWFnZSkgPT4ge1xuICAgIGlmICghaW1hZ2UuY29tcGxldGUgfHwgaW1hZ2UubmF0dXJhbFdpZHRoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhcGVyIFNoYWRlcnM6IGltYWdlIGZvciB1bmlmb3JtICR7dW5pZm9ybU5hbWV9IG11c3QgYmUgZnVsbHkgbG9hZGVkYCk7XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nVGV4dHVyZSA9IHRoaXMudGV4dHVyZXMuZ2V0KHVuaWZvcm1OYW1lKTtcbiAgICBpZiAoZXhpc3RpbmdUZXh0dXJlKSB7XG4gICAgICB0aGlzLmdsLmRlbGV0ZVRleHR1cmUoZXhpc3RpbmdUZXh0dXJlKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnRleHR1cmVVbml0TWFwLmhhcyh1bmlmb3JtTmFtZSkpIHtcbiAgICAgIHRoaXMudGV4dHVyZVVuaXRNYXAuc2V0KHVuaWZvcm1OYW1lLCB0aGlzLnRleHR1cmVVbml0TWFwLnNpemUpO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0dXJlVW5pdCA9IHRoaXMudGV4dHVyZVVuaXRNYXAuZ2V0KHVuaWZvcm1OYW1lKTtcbiAgICB0aGlzLmdsLmFjdGl2ZVRleHR1cmUodGhpcy5nbC5URVhUVVJFMCArIHRleHR1cmVVbml0KTtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5nbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgdGhpcy5nbC5iaW5kVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9XUkFQX1MsIHRoaXMuZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbC5URVhUVVJFX1dSQVBfVCwgdGhpcy5nbC5DTEFNUF9UT19FREdFKTtcbiAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGhpcy5nbC5MSU5FQVIpO1xuICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCB0aGlzLmdsLkxJTkVBUik7XG4gICAgdGhpcy5nbC50ZXhJbWFnZTJEKHRoaXMuZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5nbC5SR0JBLCB0aGlzLmdsLlJHQkEsIHRoaXMuZ2wuVU5TSUdORURfQllURSwgaW1hZ2UpO1xuICAgIGlmICh1bmlmb3JtTmFtZSAhPT0gXCJ1X25vaXNlVGV4dHVyZVwiKSB7XG4gICAgICB0aGlzLmdsLmdlbmVyYXRlTWlwbWFwKHRoaXMuZ2wuVEVYVFVSRV8yRCk7XG4gICAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGhpcy5nbC5MSU5FQVJfTUlQTUFQX0xJTkVBUik7XG4gICAgfVxuICAgIGNvbnN0IGVycm9yID0gdGhpcy5nbC5nZXRFcnJvcigpO1xuICAgIGlmIChlcnJvciAhPT0gdGhpcy5nbC5OT19FUlJPUiB8fCB0ZXh0dXJlID09PSBudWxsKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiUGFwZXIgU2hhZGVyczogV2ViR0wgZXJyb3Igd2hlbiB1cGxvYWRpbmcgdGV4dHVyZTpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnRleHR1cmVzLnNldCh1bmlmb3JtTmFtZSwgdGV4dHVyZSk7XG4gICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLnVuaWZvcm1Mb2NhdGlvbnNbdW5pZm9ybU5hbWVdO1xuICAgIGlmIChsb2NhdGlvbikge1xuICAgICAgdGhpcy5nbC51bmlmb3JtMWkobG9jYXRpb24sIHRleHR1cmVVbml0KTtcbiAgICAgIGNvbnN0IGFzcGVjdFJhdGlvVW5pZm9ybU5hbWUgPSBgJHt1bmlmb3JtTmFtZX1Bc3BlY3RSYXRpb2A7XG4gICAgICBjb25zdCBhc3BlY3RSYXRpb0xvY2F0aW9uID0gdGhpcy51bmlmb3JtTG9jYXRpb25zW2FzcGVjdFJhdGlvVW5pZm9ybU5hbWVdO1xuICAgICAgaWYgKGFzcGVjdFJhdGlvTG9jYXRpb24pIHtcbiAgICAgICAgY29uc3QgYXNwZWN0UmF0aW8gPSBpbWFnZS5uYXR1cmFsV2lkdGggLyBpbWFnZS5uYXR1cmFsSGVpZ2h0O1xuICAgICAgICB0aGlzLmdsLnVuaWZvcm0xZihhc3BlY3RSYXRpb0xvY2F0aW9uLCBhc3BlY3RSYXRpbyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKiogVXRpbGl0eTogcmVjdXJzaXZlIGVxdWFsaXR5IHRlc3QgZm9yIGFsbCB0aGUgdW5pZm9ybXMgKi9cbiAgYXJlVW5pZm9ybVZhbHVlc0VxdWFsID0gKGEsIGIpID0+IHtcbiAgICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSAmJiBhLmxlbmd0aCA9PT0gYi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBhLmV2ZXJ5KCh2YWwsIGkpID0+IHRoaXMuYXJlVW5pZm9ybVZhbHVlc0VxdWFsKHZhbCwgYltpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIC8qKiBTZXRzIHRoZSBwcm92aWRlZCB1bmlmb3JtIHZhbHVlcyBpbnRvIHRoZSBXZWJHTCBwcm9ncmFtLCBjYW4gYmUgYSBwYXJ0aWFsIGxpc3Qgb2YgdW5pZm9ybXMgdGhhdCBoYXZlIGNoYW5nZWQgKi9cbiAgc2V0VW5pZm9ybVZhbHVlcyA9ICh1cGRhdGVkVW5pZm9ybXMpID0+IHtcbiAgICB0aGlzLmdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcbiAgICBPYmplY3QuZW50cmllcyh1cGRhdGVkVW5pZm9ybXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgbGV0IGNhY2hlVmFsdWUgPSB2YWx1ZTtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcbiAgICAgICAgY2FjaGVWYWx1ZSA9IGAke3ZhbHVlLnNyYy5zbGljZSgwLCAyMDApfXwke3ZhbHVlLm5hdHVyYWxXaWR0aH14JHt2YWx1ZS5uYXR1cmFsSGVpZ2h0fWA7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5hcmVVbmlmb3JtVmFsdWVzRXF1YWwodGhpcy51bmlmb3JtQ2FjaGVba2V5XSwgY2FjaGVWYWx1ZSkpIHJldHVybjtcbiAgICAgIHRoaXMudW5pZm9ybUNhY2hlW2tleV0gPSBjYWNoZVZhbHVlO1xuICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLnVuaWZvcm1Mb2NhdGlvbnNba2V5XTtcbiAgICAgIGlmICghbG9jYXRpb24pIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBVbmlmb3JtIGxvY2F0aW9uIGZvciAke2tleX0gbm90IGZvdW5kYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5zZXRUZXh0dXJlVW5pZm9ybShrZXksIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgbGV0IGZsYXRBcnJheSA9IG51bGw7XG4gICAgICAgIGxldCB2YWx1ZUxlbmd0aCA9IG51bGw7XG4gICAgICAgIGlmICh2YWx1ZVswXSAhPT0gdm9pZCAwICYmIEFycmF5LmlzQXJyYXkodmFsdWVbMF0pKSB7XG4gICAgICAgICAgY29uc3QgZmlyc3RDaGlsZExlbmd0aCA9IHZhbHVlWzBdLmxlbmd0aDtcbiAgICAgICAgICBpZiAodmFsdWUuZXZlcnkoKGFycikgPT4gYXJyLmxlbmd0aCA9PT0gZmlyc3RDaGlsZExlbmd0aCkpIHtcbiAgICAgICAgICAgIGZsYXRBcnJheSA9IHZhbHVlLmZsYXQoKTtcbiAgICAgICAgICAgIHZhbHVlTGVuZ3RoID0gZmlyc3RDaGlsZExlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBBbGwgY2hpbGQgYXJyYXlzIG11c3QgYmUgdGhlIHNhbWUgbGVuZ3RoIGZvciAke2tleX1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmxhdEFycmF5ID0gdmFsdWU7XG4gICAgICAgICAgdmFsdWVMZW5ndGggPSBmbGF0QXJyYXkubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodmFsdWVMZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB0aGlzLmdsLnVuaWZvcm0yZnYobG9jYXRpb24sIGZsYXRBcnJheSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICB0aGlzLmdsLnVuaWZvcm0zZnYobG9jYXRpb24sIGZsYXRBcnJheSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB0aGlzLmdsLnVuaWZvcm00ZnYobG9jYXRpb24sIGZsYXRBcnJheSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICB0aGlzLmdsLnVuaWZvcm1NYXRyaXgzZnYobG9jYXRpb24sIGZhbHNlLCBmbGF0QXJyYXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIHRoaXMuZ2wudW5pZm9ybU1hdHJpeDRmdihsb2NhdGlvbiwgZmFsc2UsIGZsYXRBcnJheSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbnN1cHBvcnRlZCB1bmlmb3JtIGFycmF5IGxlbmd0aDogJHt2YWx1ZUxlbmd0aH1gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdGhpcy5nbC51bmlmb3JtMWYobG9jYXRpb24sIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICB0aGlzLmdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdmFsdWUgPyAxIDogMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oYFVuc3VwcG9ydGVkIHVuaWZvcm0gdHlwZSBmb3IgJHtrZXl9OiAke3R5cGVvZiB2YWx1ZX1gKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgLyoqIEdldHMgdGhlIGN1cnJlbnQgdG90YWwgYW5pbWF0aW9uIHRpbWUgZnJvbSAwbXMgKi9cbiAgZ2V0Q3VycmVudEZyYW1lID0gKCkgPT4ge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRGcmFtZTtcbiAgfTtcbiAgLyoqIFNldCBhIGZyYW1lIHRvIGdldCBhIGRldGVybWluaXN0aWMgcmVzdWx0LCBmcmFtZXMgYXJlIGxpdGVyYWxseSBqdXN0IG1pbGxpc2Vjb25kcyBmcm9tIHplcm8gc2luY2UgdGhlIGFuaW1hdGlvbiBzdGFydGVkICovXG4gIHNldEZyYW1lID0gKG5ld0ZyYW1lKSA9PiB7XG4gICAgdGhpcy5jdXJyZW50RnJhbWUgPSBuZXdGcmFtZTtcbiAgICB0aGlzLmxhc3RSZW5kZXJUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgdGhpcy5yZW5kZXIocGVyZm9ybWFuY2Uubm93KCkpO1xuICB9O1xuICAvKiogU2V0IGFuIGFuaW1hdGlvbiBzcGVlZCAob3IgMCB0byBzdG9wIGFuaW1hdGlvbikgKi9cbiAgc2V0U3BlZWQgPSAobmV3U3BlZWQgPSAxKSA9PiB7XG4gICAgdGhpcy5zcGVlZCA9IG5ld1NwZWVkO1xuICAgIHRoaXMuc2V0Q3VycmVudFNwZWVkKGRvY3VtZW50LmhpZGRlbiA/IDAgOiBuZXdTcGVlZCk7XG4gIH07XG4gIHNldEN1cnJlbnRTcGVlZCA9IChuZXdTcGVlZCkgPT4ge1xuICAgIHRoaXMuY3VycmVudFNwZWVkID0gbmV3U3BlZWQ7XG4gICAgaWYgKHRoaXMucmFmSWQgPT09IG51bGwgJiYgbmV3U3BlZWQgIT09IDApIHtcbiAgICAgIHRoaXMubGFzdFJlbmRlclRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIHRoaXMucmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5yZW5kZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5yYWZJZCAhPT0gbnVsbCAmJiBuZXdTcGVlZCA9PT0gMCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yYWZJZCk7XG4gICAgICB0aGlzLnJhZklkID0gbnVsbDtcbiAgICB9XG4gIH07XG4gIC8qKiBTZXQgdGhlIG1heGltdW0gcGl4ZWwgY291bnQgZm9yIHRoZSBzaGFkZXIsIHRoaXMgd2lsbCBsaW1pdCB0aGUgbnVtYmVyIG9mIHBpeGVscyB0aGF0IHdpbGwgYmUgcmVuZGVyZWQgKi9cbiAgc2V0TWF4UGl4ZWxDb3VudCA9IChuZXdNYXhQaXhlbENvdW50ID0gREVGQVVMVF9NQVhfUElYRUxfQ09VTlQpID0+IHtcbiAgICB0aGlzLm1heFBpeGVsQ291bnQgPSBuZXdNYXhQaXhlbENvdW50O1xuICAgIHRoaXMuaGFuZGxlUmVzaXplKCk7XG4gIH07XG4gIC8qKiBTZXQgdGhlIG1pbmltdW0gcGl4ZWwgcmF0aW8gZm9yIHRoZSBzaGFkZXIgKi9cbiAgc2V0TWluUGl4ZWxSYXRpbyA9IChuZXdNaW5QaXhlbFJhdGlvID0gMikgPT4ge1xuICAgIHRoaXMubWluUGl4ZWxSYXRpbyA9IG5ld01pblBpeGVsUmF0aW87XG4gICAgdGhpcy5oYW5kbGVSZXNpemUoKTtcbiAgfTtcbiAgLyoqIFVwZGF0ZSB0aGUgdW5pZm9ybXMgdGhhdCBhcmUgcHJvdmlkZWQgYnkgdGhlIG91dHNpZGUgc2hhZGVyLCBjYW4gYmUgYSBwYXJ0aWFsIHNldCB3aXRoIG9ubHkgdGhlIHVuaWZvcm1zIHRoYXQgaGF2ZSBjaGFuZ2VkICovXG4gIHNldFVuaWZvcm1zID0gKG5ld1VuaWZvcm1zKSA9PiB7XG4gICAgdGhpcy5zZXRVbmlmb3JtVmFsdWVzKG5ld1VuaWZvcm1zKTtcbiAgICB0aGlzLnByb3ZpZGVkVW5pZm9ybXMgPSB7IC4uLnRoaXMucHJvdmlkZWRVbmlmb3JtcywgLi4ubmV3VW5pZm9ybXMgfTtcbiAgICB0aGlzLnJlbmRlcihwZXJmb3JtYW5jZS5ub3coKSk7XG4gIH07XG4gIGhhbmRsZURvY3VtZW50VmlzaWJpbGl0eUNoYW5nZSA9ICgpID0+IHtcbiAgICB0aGlzLnNldEN1cnJlbnRTcGVlZChkb2N1bWVudC5oaWRkZW4gPyAwIDogdGhpcy5zcGVlZCk7XG4gIH07XG4gIC8qKiBEaXNwb3NlIG9mIHRoZSBzaGFkZXIgbW91bnQsIGNsZWFuaW5nIHVwIGFsbCBvZiB0aGUgV2ViR0wgcmVzb3VyY2VzICovXG4gIGRpc3Bvc2UgPSAoKSA9PiB7XG4gICAgdGhpcy5oYXNCZWVuRGlzcG9zZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLnJhZklkICE9PSBudWxsKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJhZklkKTtcbiAgICAgIHRoaXMucmFmSWQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5nbCAmJiB0aGlzLnByb2dyYW0pIHtcbiAgICAgIHRoaXMudGV4dHVyZXMuZm9yRWFjaCgodGV4dHVyZSkgPT4ge1xuICAgICAgICB0aGlzLmdsLmRlbGV0ZVRleHR1cmUodGV4dHVyZSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMudGV4dHVyZXMuY2xlYXIoKTtcbiAgICAgIHRoaXMuZ2wuZGVsZXRlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuICAgICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcbiAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUiwgbnVsbCk7XG4gICAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbnVsbCk7XG4gICAgICB0aGlzLmdsLmJpbmRSZW5kZXJidWZmZXIodGhpcy5nbC5SRU5ERVJCVUZGRVIsIG51bGwpO1xuICAgICAgdGhpcy5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5nbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgICB0aGlzLmdsLmdldEVycm9yKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuICAgIH1cbiAgICB2aXN1YWxWaWV3cG9ydD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLmhhbmRsZVZpc3VhbFZpZXdwb3J0Q2hhbmdlKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCB0aGlzLmhhbmRsZURvY3VtZW50VmlzaWJpbGl0eUNoYW5nZSk7XG4gICAgdGhpcy51bmlmb3JtTG9jYXRpb25zID0ge307XG4gICAgdGhpcy5jYW52YXNFbGVtZW50LnJlbW92ZSgpO1xuICAgIGRlbGV0ZSB0aGlzLnBhcmVudEVsZW1lbnQucGFwZXJTaGFkZXJNb3VudDtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNoYWRlcihnbCwgdHlwZSwgc291cmNlKSB7XG4gIGNvbnN0IHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcih0eXBlKTtcbiAgaWYgKCFzaGFkZXIpIHJldHVybiBudWxsO1xuICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpO1xuICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG4gIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkFuIGVycm9yIG9jY3VycmVkIGNvbXBpbGluZyB0aGUgc2hhZGVyczogXCIgKyBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikpO1xuICAgIGdsLmRlbGV0ZVNoYWRlcihzaGFkZXIpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBzaGFkZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVQcm9ncmFtKGdsLCB2ZXJ0ZXhTaGFkZXJTb3VyY2UyLCBmcmFnbWVudFNoYWRlclNvdXJjZSkge1xuICBjb25zdCBmb3JtYXQgPSBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5NRURJVU1fRkxPQVQpO1xuICBjb25zdCBwcmVjaXNpb24gPSBmb3JtYXQgPyBmb3JtYXQucHJlY2lzaW9uIDogbnVsbDtcbiAgaWYgKHByZWNpc2lvbiAmJiBwcmVjaXNpb24gPCAyMykge1xuICAgIHZlcnRleFNoYWRlclNvdXJjZTIgPSB2ZXJ0ZXhTaGFkZXJTb3VyY2UyLnJlcGxhY2UoL3ByZWNpc2lvblxccysobG93cHxtZWRpdW1wKVxccytmbG9hdDsvZywgXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XCIpO1xuICAgIGZyYWdtZW50U2hhZGVyU291cmNlID0gZnJhZ21lbnRTaGFkZXJTb3VyY2UucmVwbGFjZSgvcHJlY2lzaW9uXFxzKyhsb3dwfG1lZGl1bXApXFxzK2Zsb2F0L2csIFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0XCIpLnJlcGxhY2UoL1xcYih1bmlmb3JtfHZhcnlpbmd8YXR0cmlidXRlKVxccysobG93cHxtZWRpdW1wKVxccysoXFx3KykvZywgXCIkMSBoaWdocCAkM1wiKTtcbiAgfVxuICBjb25zdCB2ZXJ0ZXhTaGFkZXIgPSBjcmVhdGVTaGFkZXIoZ2wsIGdsLlZFUlRFWF9TSEFERVIsIHZlcnRleFNoYWRlclNvdXJjZTIpO1xuICBjb25zdCBmcmFnbWVudFNoYWRlciA9IGNyZWF0ZVNoYWRlcihnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCBmcmFnbWVudFNoYWRlclNvdXJjZSk7XG4gIGlmICghdmVydGV4U2hhZGVyIHx8ICFmcmFnbWVudFNoYWRlcikgcmV0dXJuIG51bGw7XG4gIGNvbnN0IHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gIGlmICghcHJvZ3JhbSkgcmV0dXJuIG51bGw7XG4gIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xuICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xuICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcbiAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJVbmFibGUgdG8gaW5pdGlhbGl6ZSB0aGUgc2hhZGVyIHByb2dyYW06IFwiICsgZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSkpO1xuICAgIGdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgZ2wuZGVsZXRlU2hhZGVyKHZlcnRleFNoYWRlcik7XG4gICAgZ2wuZGVsZXRlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnbC5kZXRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcbiAgZ2wuZGV0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcbiAgZ2wuZGVsZXRlU2hhZGVyKHZlcnRleFNoYWRlcik7XG4gIGdsLmRlbGV0ZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XG4gIHJldHVybiBwcm9ncmFtO1xufVxuY29uc3QgZGVmYXVsdFN0eWxlID0gYEBsYXllciBwYXBlci1zaGFkZXJzIHtcbiAgOndoZXJlKFtkYXRhLXBhcGVyLXNoYWRlcl0pIHtcbiAgICBpc29sYXRpb246IGlzb2xhdGU7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuXG4gICAgJiBjYW52YXMge1xuICAgICAgY29udGFpbjogc3RyaWN0O1xuICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICBpbnNldDogMDtcbiAgICAgIHotaW5kZXg6IC0xO1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICBib3JkZXItcmFkaXVzOiBpbmhlcml0O1xuICAgICAgY29ybmVyLXNoYXBlOiBpbmhlcml0O1xuICAgIH1cbiAgfVxufWA7XG5mdW5jdGlvbiBpc1BhcGVyU2hhZGVyRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBcInBhcGVyU2hhZGVyTW91bnRcIiBpbiBlbGVtZW50O1xufVxuZnVuY3Rpb24gaXNTYWZhcmkoKSB7XG4gIGNvbnN0IHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gdWEuaW5jbHVkZXMoXCJzYWZhcmlcIikgJiYgIXVhLmluY2x1ZGVzKFwiY2hyb21lXCIpICYmICF1YS5pbmNsdWRlcyhcImFuZHJvaWRcIik7XG59XG5mdW5jdGlvbiBiZXN0R3Vlc3NCcm93c2VyWm9vbSgpIHtcbiAgY29uc3Qgdmlld3BvcnRTY2FsZSA9IHZpc3VhbFZpZXdwb3J0Py5zY2FsZSA/PyAxO1xuICBjb25zdCB2aWV3cG9ydFdpZHRoID0gdmlzdWFsVmlld3BvcnQ/LndpZHRoID8/IHdpbmRvdy5pbm5lcldpZHRoO1xuICBjb25zdCBzY3JvbGxiYXJXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoIC0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICBjb25zdCBpbm5lcldpZHRoID0gdmlld3BvcnRTY2FsZSAqIHZpZXdwb3J0V2lkdGggKyBzY3JvbGxiYXJXaWR0aDtcbiAgY29uc3QgcmF0aW8gPSBvdXRlcldpZHRoIC8gaW5uZXJXaWR0aDtcbiAgY29uc3Qgem9vbVBlcmNlbnRhZ2VSb3VuZGVkID0gTWF0aC5yb3VuZCgxMDAgKiByYXRpbyk7XG4gIGlmICh6b29tUGVyY2VudGFnZVJvdW5kZWQgJSA1ID09PSAwKSB7XG4gICAgcmV0dXJuIHpvb21QZXJjZW50YWdlUm91bmRlZCAvIDEwMDtcbiAgfVxuICBpZiAoem9vbVBlcmNlbnRhZ2VSb3VuZGVkID09PSAzMykge1xuICAgIHJldHVybiAxIC8gMztcbiAgfVxuICBpZiAoem9vbVBlcmNlbnRhZ2VSb3VuZGVkID09PSA2Nykge1xuICAgIHJldHVybiAyIC8gMztcbiAgfVxuICBpZiAoem9vbVBlcmNlbnRhZ2VSb3VuZGVkID09PSAxMzMpIHtcbiAgICByZXR1cm4gNCAvIDM7XG4gIH1cbiAgcmV0dXJuIHJhdGlvO1xufVxuZXhwb3J0IHtcbiAgU2hhZGVyTW91bnQsXG4gIGlzUGFwZXJTaGFkZXJFbGVtZW50XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhZGVyLW1vdW50LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/shader-mount.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/shader-sizing.js":
/*!******************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/shader-sizing.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShaderFitOptions: () => (/* binding */ ShaderFitOptions),\n/* harmony export */   defaultObjectSizing: () => (/* binding */ defaultObjectSizing),\n/* harmony export */   defaultPatternSizing: () => (/* binding */ defaultPatternSizing),\n/* harmony export */   drawSizingHelpers: () => (/* binding */ drawSizingHelpers),\n/* harmony export */   sizingDebugVariablesDeclaration: () => (/* binding */ sizingDebugVariablesDeclaration),\n/* harmony export */   sizingUV: () => (/* binding */ sizingUV),\n/* harmony export */   sizingUniformsDeclaration: () => (/* binding */ sizingUniformsDeclaration),\n/* harmony export */   sizingVariablesDeclaration: () => (/* binding */ sizingVariablesDeclaration)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nconst sizingVariablesDeclaration = `\nin vec2 v_objectUV;\nin vec2 v_responsiveUV;\nin vec2 v_responsiveBoxGivenSize;\nin vec2 v_patternUV;\nin vec2 v_imageUV;`;\nconst sizingDebugVariablesDeclaration = `\nin vec2 v_objectBoxSize;\nin vec2 v_objectHelperBox;\nin vec2 v_responsiveBoxSize;\nin vec2 v_responsiveHelperBox;\nin vec2 v_patternBoxSize;\nin vec2 v_patternHelperBox;`;\nconst sizingUniformsDeclaration = `\nuniform float u_originX;\nuniform float u_originY;\nuniform float u_worldWidth;\nuniform float u_worldHeight;\nuniform float u_fit;\n\nuniform float u_scale;\nuniform float u_rotation;\nuniform float u_offsetX;\nuniform float u_offsetY;`;\nconst sizingUV = `\n\n  vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n  #ifdef USE_PIXELIZATION\n    float pxSize = u_pxSize * u_pixelRatio;\n    vec2 pxSizeUv = gl_FragCoord.xy;\n    pxSizeUv -= .5 * u_resolution;\n    pxSizeUv /= pxSize;\n    uv = floor(pxSizeUv) * pxSize / u_resolution.xy;    \n    uv += .5;\n  #endif\n  uv -= .5;\n\n  \n  // ===================================================\n  // sizing params shared between objects and patterns\n  \n  vec2 boxOrigin = vec2(.5 - u_originX, u_originY - .5);\n  vec2 givenBoxSize = vec2(u_worldWidth, u_worldHeight);\n  givenBoxSize = max(givenBoxSize, vec2(1.)) * u_pixelRatio;\n  float r = u_rotation * 3.14159265358979323846 / 180.;\n  mat2 graphicRotation = mat2(cos(r), sin(r), -sin(r), cos(r));\n  vec2 graphicOffset = vec2(-u_offsetX, u_offsetY);\n\n  \n  // ===================================================\n  // Sizing api for objects (graphics with fixed ratio)\n\n  #ifdef USE_OBJECT_SIZING\n    float fixedRatio = 1.;\n    vec2 fixedRatioBoxGivenSize = vec2(\n      (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n      (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n    );\n    vec2 objectBoxSize = vec2(0.);\n    // fit = none\n    objectBoxSize.x = fixedRatio * min(fixedRatioBoxGivenSize.x / fixedRatio, fixedRatioBoxGivenSize.y);\n    if (u_fit == 1.) { // fit = contain\n      objectBoxSize.x = fixedRatio * min(u_resolution.x / fixedRatio, u_resolution.y);\n    } else if (u_fit == 2.) {  // fit = cover\n      objectBoxSize.x = fixedRatio * max(u_resolution.x / fixedRatio, u_resolution.y);\n    }\n    objectBoxSize.y = objectBoxSize.x / fixedRatio;\n    vec2 objectWorldScale = u_resolution.xy / objectBoxSize;\n  \n    #ifdef ADD_HELPERS\n      vec2 objectHelperBox = gl_FragCoord.xy / u_resolution.xy;\n      objectHelperBox -= .5;\n      objectHelperBox *= objectWorldScale;\n      objectHelperBox += boxOrigin * (objectWorldScale - 1.);  \n    #endif\n  \n    vec2 objectUV = uv;\n    objectUV *= objectWorldScale;\n    objectUV += boxOrigin * (objectWorldScale - 1.);\n    objectUV += vec2(-u_offsetX, u_offsetY);\n    objectUV /= u_scale;\n    objectUV = graphicRotation * objectUV;\n  #endif\n  \n  // ===================================================\n \n  // ===================================================\n  // Sizing api for patterns (graphics respecting u_worldWidth / u_worldHeight ratio)\n  \n  #ifdef USE_PATTERN_SIZING\n    float patternBoxRatio = givenBoxSize.x / givenBoxSize.y;\n    vec2 patternBoxGivenSize = vec2(\n      (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n      (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n    );\n    vec2 patternBoxSize = vec2(0.);\n    // fit = none\n    patternBoxSize.x = patternBoxRatio * min(patternBoxGivenSize.x / patternBoxRatio, patternBoxGivenSize.y);\n    float patternWorldNoFitBoxWidth = patternBoxSize.x;\n    if (u_fit == 1.) {  // fit = contain\n      patternBoxSize.x = patternBoxRatio * min(u_resolution.x / patternBoxRatio, u_resolution.y);\n    } else if (u_fit == 2.) {  // fit = cover\n      patternBoxSize.x = patternBoxRatio * max(u_resolution.x / patternBoxRatio, u_resolution.y);\n    }\n    patternBoxSize.y = patternBoxSize.x / patternBoxRatio;\n    vec2 patternWorldScale = u_resolution.xy / patternBoxSize;\n  \n    #ifdef ADD_HELPERS  \n      vec2 patternHelperBox = gl_FragCoord.xy / u_resolution.xy;\n      patternHelperBox -= .5;\n      patternHelperBox *= patternWorldScale;\n      patternHelperBox += boxOrigin * (patternWorldScale - 1.);  \n    #endif\n  \n    vec2 patternUV = uv;\n    patternUV += vec2(-u_offsetX, u_offsetY) / patternWorldScale;\n    patternUV += boxOrigin;\n    patternUV -= boxOrigin / patternWorldScale;\n    patternUV *= u_resolution.xy;\n    patternUV /= u_pixelRatio;\n    if (u_fit > 0.) {\n      patternUV *= (patternWorldNoFitBoxWidth / patternBoxSize.x);\n    }\n    patternUV /= u_scale;\n    patternUV = graphicRotation * patternUV;\n    patternUV += boxOrigin / patternWorldScale;\n    patternUV -= boxOrigin;\n    patternUV += .5;\n  #endif\n    \n  // ===================================================\n \n  // ===================================================\n  // Sizing api for image filters\n  \n  #ifdef USE_IMAGE_SIZING\n\n    vec2 imageBoxSize;\n    if (u_fit == 1.) { // contain\n      imageBoxSize.x = min(u_resolution.x / u_imageAspectRatio, u_resolution.y) * u_imageAspectRatio;\n    } else if (u_fit == 2.) { // cover\n      imageBoxSize.x = max(u_resolution.x / u_imageAspectRatio, u_resolution.y) * u_imageAspectRatio;\n    } else {\n      imageBoxSize.x = min(10.0, 10.0 / u_imageAspectRatio * u_imageAspectRatio);\n    }\n    imageBoxSize.y = imageBoxSize.x / u_imageAspectRatio;\n    vec2 imageBoxScale = u_resolution.xy / imageBoxSize;\n\n    #ifdef ADD_HELPERS\n      vec2 imageHelperBox = uv;\n      imageHelperBox *= imageBoxScale;\n      imageHelperBox += boxOrigin * (imageBoxScale - 1.);\n    #endif\n\n    vec2 imageUV = uv;\n    imageUV *= imageBoxScale;\n    imageUV += boxOrigin * (imageBoxScale - 1.);\n    imageUV += graphicOffset;\n    imageUV /= u_scale;\n    imageUV.x *= u_imageAspectRatio;\n    imageUV = graphicRotation * imageUV;\n    imageUV.x /= u_imageAspectRatio;\n    \n    imageUV += .5;\n    imageUV.y = 1. - imageUV.y;\n  #endif\n`;\nconst drawSizingHelpers = `\n  vec2 worldBoxDist = abs(helperBox);\n  float boxStroke = (step(max(worldBoxDist.x, worldBoxDist.y), .5) - step(max(worldBoxDist.x, worldBoxDist.y), .495));\n  color.rgb = mix(color.rgb, vec3(1., 0., 0.), boxStroke);\n  opacity += boxStroke;\n\n  vec2 boxOriginCopy = vec2(.5 - u_originX, u_originY - .5);\n  vec2 boxOriginDist = helperBox + boxOriginCopy;\n  boxOriginDist.x *= (boxSize.x / boxSize.y);\n  float boxOriginPoint = 1. - smoothstep(0., .05, length(boxOriginDist));\n  \n  vec2 graphicOriginPointDist = helperBox + vec2(-u_offsetX, u_offsetY);\n  graphicOriginPointDist.x *= (boxSize.x / boxSize.y);\n  float graphicOriginPoint = 1. - smoothstep(0., .05, length(graphicOriginPointDist));\n  \n  color.rgb = mix(color.rgb, vec3(0., 1., 0.), boxOriginPoint);\n  opacity += boxOriginPoint;\n  color.rgb = mix(color.rgb, vec3(0., 0., 1.), graphicOriginPoint);\n  opacity += graphicOriginPoint;\n`;\nconst defaultObjectSizing = {\n  fit: \"contain\",\n  scale: 1,\n  rotation: 0,\n  offsetX: 0,\n  offsetY: 0,\n  originX: 0.5,\n  originY: 0.5,\n  worldWidth: 0,\n  worldHeight: 0\n};\nconst defaultPatternSizing = {\n  fit: \"none\",\n  scale: 1,\n  rotation: 0,\n  offsetX: 0,\n  offsetY: 0,\n  originX: 0.5,\n  originY: 0.5,\n  worldWidth: 0,\n  worldHeight: 0\n};\nconst ShaderFitOptions = {\n  none: 0,\n  contain: 1,\n  cover: 2\n};\n\n//# sourceMappingURL=shader-sizing.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLXNpemluZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLE1BQU0seUJBQXlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxNQUFNLHlCQUF5QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLE1BQU0sd0JBQXdCO0FBQzlCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFVRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvYXJ0dGljZm94L0Rlc2t0b3AvV29yay9waG90b2FwcC9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLXNpemluZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogICAgICAgICAgICAgICAgICAgIFBhcGVyIFNoYWRlcnMgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXBlci1kZXNpZ24vc2hhZGVycyAgICAgICAqXG4gKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKi9cblxuY29uc3Qgc2l6aW5nVmFyaWFibGVzRGVjbGFyYXRpb24gPSBgXG5pbiB2ZWMyIHZfb2JqZWN0VVY7XG5pbiB2ZWMyIHZfcmVzcG9uc2l2ZVVWO1xuaW4gdmVjMiB2X3Jlc3BvbnNpdmVCb3hHaXZlblNpemU7XG5pbiB2ZWMyIHZfcGF0dGVyblVWO1xuaW4gdmVjMiB2X2ltYWdlVVY7YDtcbmNvbnN0IHNpemluZ0RlYnVnVmFyaWFibGVzRGVjbGFyYXRpb24gPSBgXG5pbiB2ZWMyIHZfb2JqZWN0Qm94U2l6ZTtcbmluIHZlYzIgdl9vYmplY3RIZWxwZXJCb3g7XG5pbiB2ZWMyIHZfcmVzcG9uc2l2ZUJveFNpemU7XG5pbiB2ZWMyIHZfcmVzcG9uc2l2ZUhlbHBlckJveDtcbmluIHZlYzIgdl9wYXR0ZXJuQm94U2l6ZTtcbmluIHZlYzIgdl9wYXR0ZXJuSGVscGVyQm94O2A7XG5jb25zdCBzaXppbmdVbmlmb3Jtc0RlY2xhcmF0aW9uID0gYFxudW5pZm9ybSBmbG9hdCB1X29yaWdpblg7XG51bmlmb3JtIGZsb2F0IHVfb3JpZ2luWTtcbnVuaWZvcm0gZmxvYXQgdV93b3JsZFdpZHRoO1xudW5pZm9ybSBmbG9hdCB1X3dvcmxkSGVpZ2h0O1xudW5pZm9ybSBmbG9hdCB1X2ZpdDtcblxudW5pZm9ybSBmbG9hdCB1X3NjYWxlO1xudW5pZm9ybSBmbG9hdCB1X3JvdGF0aW9uO1xudW5pZm9ybSBmbG9hdCB1X29mZnNldFg7XG51bmlmb3JtIGZsb2F0IHVfb2Zmc2V0WTtgO1xuY29uc3Qgc2l6aW5nVVYgPSBgXG5cbiAgdmVjMiB1diA9IGdsX0ZyYWdDb29yZC54eSAvIHVfcmVzb2x1dGlvbi54eTtcbiAgI2lmZGVmIFVTRV9QSVhFTElaQVRJT05cbiAgICBmbG9hdCBweFNpemUgPSB1X3B4U2l6ZSAqIHVfcGl4ZWxSYXRpbztcbiAgICB2ZWMyIHB4U2l6ZVV2ID0gZ2xfRnJhZ0Nvb3JkLnh5O1xuICAgIHB4U2l6ZVV2IC09IC41ICogdV9yZXNvbHV0aW9uO1xuICAgIHB4U2l6ZVV2IC89IHB4U2l6ZTtcbiAgICB1diA9IGZsb29yKHB4U2l6ZVV2KSAqIHB4U2l6ZSAvIHVfcmVzb2x1dGlvbi54eTsgICAgXG4gICAgdXYgKz0gLjU7XG4gICNlbmRpZlxuICB1diAtPSAuNTtcblxuICBcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIHNpemluZyBwYXJhbXMgc2hhcmVkIGJldHdlZW4gb2JqZWN0cyBhbmQgcGF0dGVybnNcbiAgXG4gIHZlYzIgYm94T3JpZ2luID0gdmVjMiguNSAtIHVfb3JpZ2luWCwgdV9vcmlnaW5ZIC0gLjUpO1xuICB2ZWMyIGdpdmVuQm94U2l6ZSA9IHZlYzIodV93b3JsZFdpZHRoLCB1X3dvcmxkSGVpZ2h0KTtcbiAgZ2l2ZW5Cb3hTaXplID0gbWF4KGdpdmVuQm94U2l6ZSwgdmVjMigxLikpICogdV9waXhlbFJhdGlvO1xuICBmbG9hdCByID0gdV9yb3RhdGlvbiAqIDMuMTQxNTkyNjUzNTg5NzkzMjM4NDYgLyAxODAuO1xuICBtYXQyIGdyYXBoaWNSb3RhdGlvbiA9IG1hdDIoY29zKHIpLCBzaW4ociksIC1zaW4ociksIGNvcyhyKSk7XG4gIHZlYzIgZ3JhcGhpY09mZnNldCA9IHZlYzIoLXVfb2Zmc2V0WCwgdV9vZmZzZXRZKTtcblxuICBcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFNpemluZyBhcGkgZm9yIG9iamVjdHMgKGdyYXBoaWNzIHdpdGggZml4ZWQgcmF0aW8pXG5cbiAgI2lmZGVmIFVTRV9PQkpFQ1RfU0laSU5HXG4gICAgZmxvYXQgZml4ZWRSYXRpbyA9IDEuO1xuICAgIHZlYzIgZml4ZWRSYXRpb0JveEdpdmVuU2l6ZSA9IHZlYzIoXG4gICAgICAodV93b3JsZFdpZHRoID09IDAuKSA/IHVfcmVzb2x1dGlvbi54IDogZ2l2ZW5Cb3hTaXplLngsXG4gICAgICAodV93b3JsZEhlaWdodCA9PSAwLikgPyB1X3Jlc29sdXRpb24ueSA6IGdpdmVuQm94U2l6ZS55XG4gICAgKTtcbiAgICB2ZWMyIG9iamVjdEJveFNpemUgPSB2ZWMyKDAuKTtcbiAgICAvLyBmaXQgPSBub25lXG4gICAgb2JqZWN0Qm94U2l6ZS54ID0gZml4ZWRSYXRpbyAqIG1pbihmaXhlZFJhdGlvQm94R2l2ZW5TaXplLnggLyBmaXhlZFJhdGlvLCBmaXhlZFJhdGlvQm94R2l2ZW5TaXplLnkpO1xuICAgIGlmICh1X2ZpdCA9PSAxLikgeyAvLyBmaXQgPSBjb250YWluXG4gICAgICBvYmplY3RCb3hTaXplLnggPSBmaXhlZFJhdGlvICogbWluKHVfcmVzb2x1dGlvbi54IC8gZml4ZWRSYXRpbywgdV9yZXNvbHV0aW9uLnkpO1xuICAgIH0gZWxzZSBpZiAodV9maXQgPT0gMi4pIHsgIC8vIGZpdCA9IGNvdmVyXG4gICAgICBvYmplY3RCb3hTaXplLnggPSBmaXhlZFJhdGlvICogbWF4KHVfcmVzb2x1dGlvbi54IC8gZml4ZWRSYXRpbywgdV9yZXNvbHV0aW9uLnkpO1xuICAgIH1cbiAgICBvYmplY3RCb3hTaXplLnkgPSBvYmplY3RCb3hTaXplLnggLyBmaXhlZFJhdGlvO1xuICAgIHZlYzIgb2JqZWN0V29ybGRTY2FsZSA9IHVfcmVzb2x1dGlvbi54eSAvIG9iamVjdEJveFNpemU7XG4gIFxuICAgICNpZmRlZiBBRERfSEVMUEVSU1xuICAgICAgdmVjMiBvYmplY3RIZWxwZXJCb3ggPSBnbF9GcmFnQ29vcmQueHkgLyB1X3Jlc29sdXRpb24ueHk7XG4gICAgICBvYmplY3RIZWxwZXJCb3ggLT0gLjU7XG4gICAgICBvYmplY3RIZWxwZXJCb3ggKj0gb2JqZWN0V29ybGRTY2FsZTtcbiAgICAgIG9iamVjdEhlbHBlckJveCArPSBib3hPcmlnaW4gKiAob2JqZWN0V29ybGRTY2FsZSAtIDEuKTsgIFxuICAgICNlbmRpZlxuICBcbiAgICB2ZWMyIG9iamVjdFVWID0gdXY7XG4gICAgb2JqZWN0VVYgKj0gb2JqZWN0V29ybGRTY2FsZTtcbiAgICBvYmplY3RVViArPSBib3hPcmlnaW4gKiAob2JqZWN0V29ybGRTY2FsZSAtIDEuKTtcbiAgICBvYmplY3RVViArPSB2ZWMyKC11X29mZnNldFgsIHVfb2Zmc2V0WSk7XG4gICAgb2JqZWN0VVYgLz0gdV9zY2FsZTtcbiAgICBvYmplY3RVViA9IGdyYXBoaWNSb3RhdGlvbiAqIG9iamVjdFVWO1xuICAjZW5kaWZcbiAgXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuIFxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gU2l6aW5nIGFwaSBmb3IgcGF0dGVybnMgKGdyYXBoaWNzIHJlc3BlY3RpbmcgdV93b3JsZFdpZHRoIC8gdV93b3JsZEhlaWdodCByYXRpbylcbiAgXG4gICNpZmRlZiBVU0VfUEFUVEVSTl9TSVpJTkdcbiAgICBmbG9hdCBwYXR0ZXJuQm94UmF0aW8gPSBnaXZlbkJveFNpemUueCAvIGdpdmVuQm94U2l6ZS55O1xuICAgIHZlYzIgcGF0dGVybkJveEdpdmVuU2l6ZSA9IHZlYzIoXG4gICAgICAodV93b3JsZFdpZHRoID09IDAuKSA/IHVfcmVzb2x1dGlvbi54IDogZ2l2ZW5Cb3hTaXplLngsXG4gICAgICAodV93b3JsZEhlaWdodCA9PSAwLikgPyB1X3Jlc29sdXRpb24ueSA6IGdpdmVuQm94U2l6ZS55XG4gICAgKTtcbiAgICB2ZWMyIHBhdHRlcm5Cb3hTaXplID0gdmVjMigwLik7XG4gICAgLy8gZml0ID0gbm9uZVxuICAgIHBhdHRlcm5Cb3hTaXplLnggPSBwYXR0ZXJuQm94UmF0aW8gKiBtaW4ocGF0dGVybkJveEdpdmVuU2l6ZS54IC8gcGF0dGVybkJveFJhdGlvLCBwYXR0ZXJuQm94R2l2ZW5TaXplLnkpO1xuICAgIGZsb2F0IHBhdHRlcm5Xb3JsZE5vRml0Qm94V2lkdGggPSBwYXR0ZXJuQm94U2l6ZS54O1xuICAgIGlmICh1X2ZpdCA9PSAxLikgeyAgLy8gZml0ID0gY29udGFpblxuICAgICAgcGF0dGVybkJveFNpemUueCA9IHBhdHRlcm5Cb3hSYXRpbyAqIG1pbih1X3Jlc29sdXRpb24ueCAvIHBhdHRlcm5Cb3hSYXRpbywgdV9yZXNvbHV0aW9uLnkpO1xuICAgIH0gZWxzZSBpZiAodV9maXQgPT0gMi4pIHsgIC8vIGZpdCA9IGNvdmVyXG4gICAgICBwYXR0ZXJuQm94U2l6ZS54ID0gcGF0dGVybkJveFJhdGlvICogbWF4KHVfcmVzb2x1dGlvbi54IC8gcGF0dGVybkJveFJhdGlvLCB1X3Jlc29sdXRpb24ueSk7XG4gICAgfVxuICAgIHBhdHRlcm5Cb3hTaXplLnkgPSBwYXR0ZXJuQm94U2l6ZS54IC8gcGF0dGVybkJveFJhdGlvO1xuICAgIHZlYzIgcGF0dGVybldvcmxkU2NhbGUgPSB1X3Jlc29sdXRpb24ueHkgLyBwYXR0ZXJuQm94U2l6ZTtcbiAgXG4gICAgI2lmZGVmIEFERF9IRUxQRVJTICBcbiAgICAgIHZlYzIgcGF0dGVybkhlbHBlckJveCA9IGdsX0ZyYWdDb29yZC54eSAvIHVfcmVzb2x1dGlvbi54eTtcbiAgICAgIHBhdHRlcm5IZWxwZXJCb3ggLT0gLjU7XG4gICAgICBwYXR0ZXJuSGVscGVyQm94ICo9IHBhdHRlcm5Xb3JsZFNjYWxlO1xuICAgICAgcGF0dGVybkhlbHBlckJveCArPSBib3hPcmlnaW4gKiAocGF0dGVybldvcmxkU2NhbGUgLSAxLik7ICBcbiAgICAjZW5kaWZcbiAgXG4gICAgdmVjMiBwYXR0ZXJuVVYgPSB1djtcbiAgICBwYXR0ZXJuVVYgKz0gdmVjMigtdV9vZmZzZXRYLCB1X29mZnNldFkpIC8gcGF0dGVybldvcmxkU2NhbGU7XG4gICAgcGF0dGVyblVWICs9IGJveE9yaWdpbjtcbiAgICBwYXR0ZXJuVVYgLT0gYm94T3JpZ2luIC8gcGF0dGVybldvcmxkU2NhbGU7XG4gICAgcGF0dGVyblVWICo9IHVfcmVzb2x1dGlvbi54eTtcbiAgICBwYXR0ZXJuVVYgLz0gdV9waXhlbFJhdGlvO1xuICAgIGlmICh1X2ZpdCA+IDAuKSB7XG4gICAgICBwYXR0ZXJuVVYgKj0gKHBhdHRlcm5Xb3JsZE5vRml0Qm94V2lkdGggLyBwYXR0ZXJuQm94U2l6ZS54KTtcbiAgICB9XG4gICAgcGF0dGVyblVWIC89IHVfc2NhbGU7XG4gICAgcGF0dGVyblVWID0gZ3JhcGhpY1JvdGF0aW9uICogcGF0dGVyblVWO1xuICAgIHBhdHRlcm5VViArPSBib3hPcmlnaW4gLyBwYXR0ZXJuV29ybGRTY2FsZTtcbiAgICBwYXR0ZXJuVVYgLT0gYm94T3JpZ2luO1xuICAgIHBhdHRlcm5VViArPSAuNTtcbiAgI2VuZGlmXG4gICAgXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuIFxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gU2l6aW5nIGFwaSBmb3IgaW1hZ2UgZmlsdGVyc1xuICBcbiAgI2lmZGVmIFVTRV9JTUFHRV9TSVpJTkdcblxuICAgIHZlYzIgaW1hZ2VCb3hTaXplO1xuICAgIGlmICh1X2ZpdCA9PSAxLikgeyAvLyBjb250YWluXG4gICAgICBpbWFnZUJveFNpemUueCA9IG1pbih1X3Jlc29sdXRpb24ueCAvIHVfaW1hZ2VBc3BlY3RSYXRpbywgdV9yZXNvbHV0aW9uLnkpICogdV9pbWFnZUFzcGVjdFJhdGlvO1xuICAgIH0gZWxzZSBpZiAodV9maXQgPT0gMi4pIHsgLy8gY292ZXJcbiAgICAgIGltYWdlQm94U2l6ZS54ID0gbWF4KHVfcmVzb2x1dGlvbi54IC8gdV9pbWFnZUFzcGVjdFJhdGlvLCB1X3Jlc29sdXRpb24ueSkgKiB1X2ltYWdlQXNwZWN0UmF0aW87XG4gICAgfSBlbHNlIHtcbiAgICAgIGltYWdlQm94U2l6ZS54ID0gbWluKDEwLjAsIDEwLjAgLyB1X2ltYWdlQXNwZWN0UmF0aW8gKiB1X2ltYWdlQXNwZWN0UmF0aW8pO1xuICAgIH1cbiAgICBpbWFnZUJveFNpemUueSA9IGltYWdlQm94U2l6ZS54IC8gdV9pbWFnZUFzcGVjdFJhdGlvO1xuICAgIHZlYzIgaW1hZ2VCb3hTY2FsZSA9IHVfcmVzb2x1dGlvbi54eSAvIGltYWdlQm94U2l6ZTtcblxuICAgICNpZmRlZiBBRERfSEVMUEVSU1xuICAgICAgdmVjMiBpbWFnZUhlbHBlckJveCA9IHV2O1xuICAgICAgaW1hZ2VIZWxwZXJCb3ggKj0gaW1hZ2VCb3hTY2FsZTtcbiAgICAgIGltYWdlSGVscGVyQm94ICs9IGJveE9yaWdpbiAqIChpbWFnZUJveFNjYWxlIC0gMS4pO1xuICAgICNlbmRpZlxuXG4gICAgdmVjMiBpbWFnZVVWID0gdXY7XG4gICAgaW1hZ2VVViAqPSBpbWFnZUJveFNjYWxlO1xuICAgIGltYWdlVVYgKz0gYm94T3JpZ2luICogKGltYWdlQm94U2NhbGUgLSAxLik7XG4gICAgaW1hZ2VVViArPSBncmFwaGljT2Zmc2V0O1xuICAgIGltYWdlVVYgLz0gdV9zY2FsZTtcbiAgICBpbWFnZVVWLnggKj0gdV9pbWFnZUFzcGVjdFJhdGlvO1xuICAgIGltYWdlVVYgPSBncmFwaGljUm90YXRpb24gKiBpbWFnZVVWO1xuICAgIGltYWdlVVYueCAvPSB1X2ltYWdlQXNwZWN0UmF0aW87XG4gICAgXG4gICAgaW1hZ2VVViArPSAuNTtcbiAgICBpbWFnZVVWLnkgPSAxLiAtIGltYWdlVVYueTtcbiAgI2VuZGlmXG5gO1xuY29uc3QgZHJhd1NpemluZ0hlbHBlcnMgPSBgXG4gIHZlYzIgd29ybGRCb3hEaXN0ID0gYWJzKGhlbHBlckJveCk7XG4gIGZsb2F0IGJveFN0cm9rZSA9IChzdGVwKG1heCh3b3JsZEJveERpc3QueCwgd29ybGRCb3hEaXN0LnkpLCAuNSkgLSBzdGVwKG1heCh3b3JsZEJveERpc3QueCwgd29ybGRCb3hEaXN0LnkpLCAuNDk1KSk7XG4gIGNvbG9yLnJnYiA9IG1peChjb2xvci5yZ2IsIHZlYzMoMS4sIDAuLCAwLiksIGJveFN0cm9rZSk7XG4gIG9wYWNpdHkgKz0gYm94U3Ryb2tlO1xuXG4gIHZlYzIgYm94T3JpZ2luQ29weSA9IHZlYzIoLjUgLSB1X29yaWdpblgsIHVfb3JpZ2luWSAtIC41KTtcbiAgdmVjMiBib3hPcmlnaW5EaXN0ID0gaGVscGVyQm94ICsgYm94T3JpZ2luQ29weTtcbiAgYm94T3JpZ2luRGlzdC54ICo9IChib3hTaXplLnggLyBib3hTaXplLnkpO1xuICBmbG9hdCBib3hPcmlnaW5Qb2ludCA9IDEuIC0gc21vb3Roc3RlcCgwLiwgLjA1LCBsZW5ndGgoYm94T3JpZ2luRGlzdCkpO1xuICBcbiAgdmVjMiBncmFwaGljT3JpZ2luUG9pbnREaXN0ID0gaGVscGVyQm94ICsgdmVjMigtdV9vZmZzZXRYLCB1X29mZnNldFkpO1xuICBncmFwaGljT3JpZ2luUG9pbnREaXN0LnggKj0gKGJveFNpemUueCAvIGJveFNpemUueSk7XG4gIGZsb2F0IGdyYXBoaWNPcmlnaW5Qb2ludCA9IDEuIC0gc21vb3Roc3RlcCgwLiwgLjA1LCBsZW5ndGgoZ3JhcGhpY09yaWdpblBvaW50RGlzdCkpO1xuICBcbiAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgdmVjMygwLiwgMS4sIDAuKSwgYm94T3JpZ2luUG9pbnQpO1xuICBvcGFjaXR5ICs9IGJveE9yaWdpblBvaW50O1xuICBjb2xvci5yZ2IgPSBtaXgoY29sb3IucmdiLCB2ZWMzKDAuLCAwLiwgMS4pLCBncmFwaGljT3JpZ2luUG9pbnQpO1xuICBvcGFjaXR5ICs9IGdyYXBoaWNPcmlnaW5Qb2ludDtcbmA7XG5jb25zdCBkZWZhdWx0T2JqZWN0U2l6aW5nID0ge1xuICBmaXQ6IFwiY29udGFpblwiLFxuICBzY2FsZTogMSxcbiAgcm90YXRpb246IDAsXG4gIG9mZnNldFg6IDAsXG4gIG9mZnNldFk6IDAsXG4gIG9yaWdpblg6IDAuNSxcbiAgb3JpZ2luWTogMC41LFxuICB3b3JsZFdpZHRoOiAwLFxuICB3b3JsZEhlaWdodDogMFxufTtcbmNvbnN0IGRlZmF1bHRQYXR0ZXJuU2l6aW5nID0ge1xuICBmaXQ6IFwibm9uZVwiLFxuICBzY2FsZTogMSxcbiAgcm90YXRpb246IDAsXG4gIG9mZnNldFg6IDAsXG4gIG9mZnNldFk6IDAsXG4gIG9yaWdpblg6IDAuNSxcbiAgb3JpZ2luWTogMC41LFxuICB3b3JsZFdpZHRoOiAwLFxuICB3b3JsZEhlaWdodDogMFxufTtcbmNvbnN0IFNoYWRlckZpdE9wdGlvbnMgPSB7XG4gIG5vbmU6IDAsXG4gIGNvbnRhaW46IDEsXG4gIGNvdmVyOiAyXG59O1xuZXhwb3J0IHtcbiAgU2hhZGVyRml0T3B0aW9ucyxcbiAgZGVmYXVsdE9iamVjdFNpemluZyxcbiAgZGVmYXVsdFBhdHRlcm5TaXppbmcsXG4gIGRyYXdTaXppbmdIZWxwZXJzLFxuICBzaXppbmdEZWJ1Z1ZhcmlhYmxlc0RlY2xhcmF0aW9uLFxuICBzaXppbmdVVixcbiAgc2l6aW5nVW5pZm9ybXNEZWNsYXJhdGlvbixcbiAgc2l6aW5nVmFyaWFibGVzRGVjbGFyYXRpb25cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFkZXItc2l6aW5nLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/shader-sizing.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/shader-utils.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/shader-utils.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   colorBandingFix: () => (/* binding */ colorBandingFix),\n/* harmony export */   declarePI: () => (/* binding */ declarePI),\n/* harmony export */   fiberNoise: () => (/* binding */ fiberNoise),\n/* harmony export */   proceduralHash11: () => (/* binding */ proceduralHash11),\n/* harmony export */   proceduralHash21: () => (/* binding */ proceduralHash21),\n/* harmony export */   proceduralHash22: () => (/* binding */ proceduralHash22),\n/* harmony export */   rotation2: () => (/* binding */ rotation2),\n/* harmony export */   simplexNoise: () => (/* binding */ simplexNoise),\n/* harmony export */   textureRandomizerGB: () => (/* binding */ textureRandomizerGB),\n/* harmony export */   textureRandomizerR: () => (/* binding */ textureRandomizerR)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nconst declarePI = `\n#define TWO_PI 6.28318530718\n#define PI 3.14159265358979323846\n`;\nconst rotation2 = `\nvec2 rotate(vec2 uv, float th) {\n  return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n}\n`;\nconst proceduralHash11 = `\n  float hash11(float p) {\n    p = fract(p * 0.3183099) + 0.1;\n    p *= p + 19.19;\n    return fract(p * p);\n  }\n`;\nconst proceduralHash21 = `\n  float hash21(vec2 p) {\n    p = fract(p * vec2(0.3183099, 0.3678794)) + 0.1;\n    p += dot(p, p + 19.19);\n    return fract(p.x * p.y);\n  }\n`;\nconst proceduralHash22 = `\n  vec2 hash22(vec2 p) {\n    p = fract(p * vec2(0.3183099, 0.3678794)) + 0.1;\n    p += dot(p, p.yx + 19.19);\n    return fract(vec2(p.x * p.y, p.x + p.y));\n  }\n`;\nconst textureRandomizerR = `\n  float randomR(vec2 p) {\n    vec2 uv = floor(p) / 100. + .5;\n    return texture(u_noiseTexture, fract(uv)).r;\n  }\n`;\nconst textureRandomizerGB = `\n  vec2 randomGB(vec2 p) {\n    vec2 uv = floor(p) / 100. + .5;\n    return texture(u_noiseTexture, fract(uv)).gb;\n  }\n`;\nconst colorBandingFix = `\n  color += 1. / 256. * (fract(sin(dot(.014 * gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453123) - .5);\n`;\nconst simplexNoise = `\nvec3 permute(vec3 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n    -0.577350269189626, 0.024390243902439);\n  vec2 i = floor(v + dot(v, C.yy));\n  vec2 x0 = v - i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))\n    + i.x + vec3(0.0, i1.x, 1.0));\n  vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy),\n      dot(x12.zw, x12.zw)), 0.0);\n  m = m * m;\n  m = m * m;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n  vec3 g;\n  g.x = a0.x * x0.x + h.x * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n`;\nconst fiberNoise = `\nfloat fiberRandom(vec2 p) {\n  vec2 uv = floor(p) / 100.;\n  return texture(u_noiseTexture, fract(uv)).b;\n}\n\nfloat fiberValueNoise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n  float a = fiberRandom(i);\n  float b = fiberRandom(i + vec2(1.0, 0.0));\n  float c = fiberRandom(i + vec2(0.0, 1.0));\n  float d = fiberRandom(i + vec2(1.0, 1.0));\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  float x1 = mix(a, b, u.x);\n  float x2 = mix(c, d, u.x);\n  return mix(x1, x2, u.y);\n}\n\nfloat fiberNoiseFbm(in vec2 n, vec2 seedOffset) {\n  float total = 0.0, amplitude = 1.;\n  for (int i = 0; i < 4; i++) {\n    n = rotate(n, .7);\n    total += fiberValueNoise(n + seedOffset) * amplitude;\n    n *= 2.;\n    amplitude *= 0.6;\n  }\n  return total;\n}\n\nfloat fiberNoise(vec2 uv, vec2 seedOffset) {\n  float epsilon = 0.001;\n  float n1 = fiberNoiseFbm(uv + vec2(epsilon, 0.0), seedOffset);\n  float n2 = fiberNoiseFbm(uv - vec2(epsilon, 0.0), seedOffset);\n  float n3 = fiberNoiseFbm(uv + vec2(0.0, epsilon), seedOffset);\n  float n4 = fiberNoiseFbm(uv - vec2(0.0, epsilon), seedOffset);\n  return length(vec2(n1 - n2, n3 - n4)) / (2.0 * epsilon);\n}\n`;\n\n//# sourceMappingURL=shader-utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLXV0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWUU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2FydHRpY2ZveC9EZXNrdG9wL1dvcmsvcGhvdG9hcHAvbm9kZV9tb2R1bGVzL0BwYXBlci1kZXNpZ24vc2hhZGVycy9kaXN0L3NoYWRlci11dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogICAgICAgICAgICAgICAgICAgIFBhcGVyIFNoYWRlcnMgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXBlci1kZXNpZ24vc2hhZGVycyAgICAgICAqXG4gKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKi9cblxuY29uc3QgZGVjbGFyZVBJID0gYFxuI2RlZmluZSBUV09fUEkgNi4yODMxODUzMDcxOFxuI2RlZmluZSBQSSAzLjE0MTU5MjY1MzU4OTc5MzIzODQ2XG5gO1xuY29uc3Qgcm90YXRpb24yID0gYFxudmVjMiByb3RhdGUodmVjMiB1diwgZmxvYXQgdGgpIHtcbiAgcmV0dXJuIG1hdDIoY29zKHRoKSwgc2luKHRoKSwgLXNpbih0aCksIGNvcyh0aCkpICogdXY7XG59XG5gO1xuY29uc3QgcHJvY2VkdXJhbEhhc2gxMSA9IGBcbiAgZmxvYXQgaGFzaDExKGZsb2F0IHApIHtcbiAgICBwID0gZnJhY3QocCAqIDAuMzE4MzA5OSkgKyAwLjE7XG4gICAgcCAqPSBwICsgMTkuMTk7XG4gICAgcmV0dXJuIGZyYWN0KHAgKiBwKTtcbiAgfVxuYDtcbmNvbnN0IHByb2NlZHVyYWxIYXNoMjEgPSBgXG4gIGZsb2F0IGhhc2gyMSh2ZWMyIHApIHtcbiAgICBwID0gZnJhY3QocCAqIHZlYzIoMC4zMTgzMDk5LCAwLjM2Nzg3OTQpKSArIDAuMTtcbiAgICBwICs9IGRvdChwLCBwICsgMTkuMTkpO1xuICAgIHJldHVybiBmcmFjdChwLnggKiBwLnkpO1xuICB9XG5gO1xuY29uc3QgcHJvY2VkdXJhbEhhc2gyMiA9IGBcbiAgdmVjMiBoYXNoMjIodmVjMiBwKSB7XG4gICAgcCA9IGZyYWN0KHAgKiB2ZWMyKDAuMzE4MzA5OSwgMC4zNjc4Nzk0KSkgKyAwLjE7XG4gICAgcCArPSBkb3QocCwgcC55eCArIDE5LjE5KTtcbiAgICByZXR1cm4gZnJhY3QodmVjMihwLnggKiBwLnksIHAueCArIHAueSkpO1xuICB9XG5gO1xuY29uc3QgdGV4dHVyZVJhbmRvbWl6ZXJSID0gYFxuICBmbG9hdCByYW5kb21SKHZlYzIgcCkge1xuICAgIHZlYzIgdXYgPSBmbG9vcihwKSAvIDEwMC4gKyAuNTtcbiAgICByZXR1cm4gdGV4dHVyZSh1X25vaXNlVGV4dHVyZSwgZnJhY3QodXYpKS5yO1xuICB9XG5gO1xuY29uc3QgdGV4dHVyZVJhbmRvbWl6ZXJHQiA9IGBcbiAgdmVjMiByYW5kb21HQih2ZWMyIHApIHtcbiAgICB2ZWMyIHV2ID0gZmxvb3IocCkgLyAxMDAuICsgLjU7XG4gICAgcmV0dXJuIHRleHR1cmUodV9ub2lzZVRleHR1cmUsIGZyYWN0KHV2KSkuZ2I7XG4gIH1cbmA7XG5jb25zdCBjb2xvckJhbmRpbmdGaXggPSBgXG4gIGNvbG9yICs9IDEuIC8gMjU2LiAqIChmcmFjdChzaW4oZG90KC4wMTQgKiBnbF9GcmFnQ29vcmQueHksIHZlYzIoMTIuOTg5OCwgNzguMjMzKSkpICogNDM3NTguNTQ1MzEyMykgLSAuNSk7XG5gO1xuY29uc3Qgc2ltcGxleE5vaXNlID0gYFxudmVjMyBwZXJtdXRlKHZlYzMgeCkgeyByZXR1cm4gbW9kKCgoeCAqIDM0LjApICsgMS4wKSAqIHgsIDI4OS4wKTsgfVxuZmxvYXQgc25vaXNlKHZlYzIgdikge1xuICBjb25zdCB2ZWM0IEMgPSB2ZWM0KDAuMjExMzI0ODY1NDA1MTg3LCAwLjM2NjAyNTQwMzc4NDQzOSxcbiAgICAtMC41NzczNTAyNjkxODk2MjYsIDAuMDI0MzkwMjQzOTAyNDM5KTtcbiAgdmVjMiBpID0gZmxvb3IodiArIGRvdCh2LCBDLnl5KSk7XG4gIHZlYzIgeDAgPSB2IC0gaSArIGRvdChpLCBDLnh4KTtcbiAgdmVjMiBpMTtcbiAgaTEgPSAoeDAueCA+IHgwLnkpID8gdmVjMigxLjAsIDAuMCkgOiB2ZWMyKDAuMCwgMS4wKTtcbiAgdmVjNCB4MTIgPSB4MC54eXh5ICsgQy54eHp6O1xuICB4MTIueHkgLT0gaTE7XG4gIGkgPSBtb2QoaSwgMjg5LjApO1xuICB2ZWMzIHAgPSBwZXJtdXRlKHBlcm11dGUoaS55ICsgdmVjMygwLjAsIGkxLnksIDEuMCkpXG4gICAgKyBpLnggKyB2ZWMzKDAuMCwgaTEueCwgMS4wKSk7XG4gIHZlYzMgbSA9IG1heCgwLjUgLSB2ZWMzKGRvdCh4MCwgeDApLCBkb3QoeDEyLnh5LCB4MTIueHkpLFxuICAgICAgZG90KHgxMi56dywgeDEyLnp3KSksIDAuMCk7XG4gIG0gPSBtICogbTtcbiAgbSA9IG0gKiBtO1xuICB2ZWMzIHggPSAyLjAgKiBmcmFjdChwICogQy53d3cpIC0gMS4wO1xuICB2ZWMzIGggPSBhYnMoeCkgLSAwLjU7XG4gIHZlYzMgb3ggPSBmbG9vcih4ICsgMC41KTtcbiAgdmVjMyBhMCA9IHggLSBveDtcbiAgbSAqPSAxLjc5Mjg0MjkxNDAwMTU5IC0gMC44NTM3MzQ3MjA5NTMxNCAqIChhMCAqIGEwICsgaCAqIGgpO1xuICB2ZWMzIGc7XG4gIGcueCA9IGEwLnggKiB4MC54ICsgaC54ICogeDAueTtcbiAgZy55eiA9IGEwLnl6ICogeDEyLnh6ICsgaC55eiAqIHgxMi55dztcbiAgcmV0dXJuIDEzMC4wICogZG90KG0sIGcpO1xufVxuYDtcbmNvbnN0IGZpYmVyTm9pc2UgPSBgXG5mbG9hdCBmaWJlclJhbmRvbSh2ZWMyIHApIHtcbiAgdmVjMiB1diA9IGZsb29yKHApIC8gMTAwLjtcbiAgcmV0dXJuIHRleHR1cmUodV9ub2lzZVRleHR1cmUsIGZyYWN0KHV2KSkuYjtcbn1cblxuZmxvYXQgZmliZXJWYWx1ZU5vaXNlKHZlYzIgc3QpIHtcbiAgdmVjMiBpID0gZmxvb3Ioc3QpO1xuICB2ZWMyIGYgPSBmcmFjdChzdCk7XG4gIGZsb2F0IGEgPSBmaWJlclJhbmRvbShpKTtcbiAgZmxvYXQgYiA9IGZpYmVyUmFuZG9tKGkgKyB2ZWMyKDEuMCwgMC4wKSk7XG4gIGZsb2F0IGMgPSBmaWJlclJhbmRvbShpICsgdmVjMigwLjAsIDEuMCkpO1xuICBmbG9hdCBkID0gZmliZXJSYW5kb20oaSArIHZlYzIoMS4wLCAxLjApKTtcbiAgdmVjMiB1ID0gZiAqIGYgKiAoMy4wIC0gMi4wICogZik7XG4gIGZsb2F0IHgxID0gbWl4KGEsIGIsIHUueCk7XG4gIGZsb2F0IHgyID0gbWl4KGMsIGQsIHUueCk7XG4gIHJldHVybiBtaXgoeDEsIHgyLCB1LnkpO1xufVxuXG5mbG9hdCBmaWJlck5vaXNlRmJtKGluIHZlYzIgbiwgdmVjMiBzZWVkT2Zmc2V0KSB7XG4gIGZsb2F0IHRvdGFsID0gMC4wLCBhbXBsaXR1ZGUgPSAxLjtcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBuID0gcm90YXRlKG4sIC43KTtcbiAgICB0b3RhbCArPSBmaWJlclZhbHVlTm9pc2UobiArIHNlZWRPZmZzZXQpICogYW1wbGl0dWRlO1xuICAgIG4gKj0gMi47XG4gICAgYW1wbGl0dWRlICo9IDAuNjtcbiAgfVxuICByZXR1cm4gdG90YWw7XG59XG5cbmZsb2F0IGZpYmVyTm9pc2UodmVjMiB1diwgdmVjMiBzZWVkT2Zmc2V0KSB7XG4gIGZsb2F0IGVwc2lsb24gPSAwLjAwMTtcbiAgZmxvYXQgbjEgPSBmaWJlck5vaXNlRmJtKHV2ICsgdmVjMihlcHNpbG9uLCAwLjApLCBzZWVkT2Zmc2V0KTtcbiAgZmxvYXQgbjIgPSBmaWJlck5vaXNlRmJtKHV2IC0gdmVjMihlcHNpbG9uLCAwLjApLCBzZWVkT2Zmc2V0KTtcbiAgZmxvYXQgbjMgPSBmaWJlck5vaXNlRmJtKHV2ICsgdmVjMigwLjAsIGVwc2lsb24pLCBzZWVkT2Zmc2V0KTtcbiAgZmxvYXQgbjQgPSBmaWJlck5vaXNlRmJtKHV2IC0gdmVjMigwLjAsIGVwc2lsb24pLCBzZWVkT2Zmc2V0KTtcbiAgcmV0dXJuIGxlbmd0aCh2ZWMyKG4xIC0gbjIsIG4zIC0gbjQpKSAvICgyLjAgKiBlcHNpbG9uKTtcbn1cbmA7XG5leHBvcnQge1xuICBjb2xvckJhbmRpbmdGaXgsXG4gIGRlY2xhcmVQSSxcbiAgZmliZXJOb2lzZSxcbiAgcHJvY2VkdXJhbEhhc2gxMSxcbiAgcHJvY2VkdXJhbEhhc2gyMSxcbiAgcHJvY2VkdXJhbEhhc2gyMixcbiAgcm90YXRpb24yLFxuICBzaW1wbGV4Tm9pc2UsXG4gIHRleHR1cmVSYW5kb21pemVyR0IsXG4gIHRleHR1cmVSYW5kb21pemVyUlxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYWRlci11dGlscy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/shader-utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/shaders/swirl.js":
/*!******************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/shaders/swirl.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   swirlFragmentShader: () => (/* binding */ swirlFragmentShader),\n/* harmony export */   swirlMeta: () => (/* binding */ swirlMeta)\n/* harmony export */ });\n/* harmony import */ var _shader_sizing_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shader-sizing.js */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shader-sizing.js\");\n/* harmony import */ var _shader_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shader-utils.js */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shader-utils.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\n\nconst swirlMeta = {\n  maxColorCount: 10\n};\nconst swirlFragmentShader = `#version 300 es\nprecision mediump float;\n\nuniform float u_time;\n\nuniform vec4 u_colorBack;\nuniform vec4 u_colors[${swirlMeta.maxColorCount}];\nuniform float u_colorsCount;\nuniform float u_bandCount;\nuniform float u_twist;\nuniform float u_center;\nuniform float u_proportion;\nuniform float u_softness;\nuniform float u_noise;\nuniform float u_noiseFrequency;\n\n${_shader_sizing_js__WEBPACK_IMPORTED_MODULE_0__.sizingVariablesDeclaration}\n\nout vec4 fragColor;\n\n${_shader_utils_js__WEBPACK_IMPORTED_MODULE_1__.declarePI}\n${_shader_utils_js__WEBPACK_IMPORTED_MODULE_1__.simplexNoise}\n${_shader_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotation2}\n\nvoid main() {\n  vec2 shape_uv = v_objectUV;\n\n  float l = length(shape_uv);\n  l = max(1e-4, l);\n  \n  float t = u_time;\n\n  float angle = ceil(u_bandCount) * atan(shape_uv.y, shape_uv.x) + t;\n  float angle_norm = angle / TWO_PI;\n\n  float twist = 3. * clamp(u_twist, 0., 1.);\n  float offset = pow(l, -twist) + angle_norm;\n\n  float shape = fract(offset);\n  shape = 1. - abs(2. * shape - 1.);\n  shape += u_noise * snoise(15. * pow(u_noiseFrequency, 2.) * shape_uv);\n\n  float mid = smoothstep(.2, .2 + .8 * u_center, pow(l, twist));\n  shape = mix(0., shape, mid);\n\n  float proportion = clamp(u_proportion, 0., 1.);\n  float exponent = mix(.25, 1., proportion * 2.);\n  exponent = mix(exponent, 10., max(0., proportion * 2. - 1.));\n  shape = pow(shape, exponent);\n\n  float mixer = shape * u_colorsCount;\n  vec4 gradient = u_colors[0];\n  gradient.rgb *= gradient.a;\n  \n  float outerShape = 0.;\n  for (int i = 1; i < ${swirlMeta.maxColorCount + 1}; i++) {\n    if (i > int(u_colorsCount)) break;\n\n    float m = clamp(mixer - float(i - 1), 0., 1.);\n    float aa = fwidth(m);\n    m = smoothstep(.5 - .5 * u_softness - aa, .5 + .5 * u_softness + aa, m);\n\n    if (i == 1) {\n      outerShape = m;\n    }\n\n    vec4 c = u_colors[i - 1];\n    c.rgb *= c.a;\n    gradient = mix(gradient, c, m);\n  }\n\n  float midAA = .1 * fwidth(pow(l, -twist));\n  float outerMid = smoothstep(.2, .2 + midAA, pow(l, twist));\n  outerShape = mix(0., outerShape, outerMid);\n\n  vec3 color = gradient.rgb * outerShape;\n  float opacity = gradient.a * outerShape;\n\n  vec3 bgColor = u_colorBack.rgb * u_colorBack.a;\n  color = color + bgColor * (1.0 - opacity);\n  opacity = opacity + u_colorBack.a * (1.0 - opacity);\n\n  ${_shader_utils_js__WEBPACK_IMPORTED_MODULE_1__.colorBandingFix}\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\n//# sourceMappingURL=swirl.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVycy9zd2lybC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRWlFO0FBQ3dCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSx5RUFBMEI7O0FBRTVCOztBQUVBLEVBQUUsdURBQVM7QUFDWCxFQUFFLDBEQUFZO0FBQ2QsRUFBRSx1REFBUzs7QUFFWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE1BQU0sOEJBQThCO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUksNkRBQWU7O0FBRW5CO0FBQ0E7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcnR0aWNmb3gvRGVza3RvcC9Xb3JrL3Bob3RvYXBwL25vZGVfbW9kdWxlcy9AcGFwZXItZGVzaWduL3NoYWRlcnMvZGlzdC9zaGFkZXJzL3N3aXJsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiAgICAgICAgICAgICAgICAgICAgUGFwZXIgU2hhZGVycyAgICAgICAgICAgICAgICAgICAgKlxuICogICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3BhcGVyLWRlc2lnbi9zaGFkZXJzICAgICAgICpcbiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuXG5pbXBvcnQgeyBzaXppbmdWYXJpYWJsZXNEZWNsYXJhdGlvbiB9IGZyb20gXCIuLi9zaGFkZXItc2l6aW5nLmpzXCI7XG5pbXBvcnQgeyBzaW1wbGV4Tm9pc2UsIGRlY2xhcmVQSSwgcm90YXRpb24yLCBjb2xvckJhbmRpbmdGaXggfSBmcm9tIFwiLi4vc2hhZGVyLXV0aWxzLmpzXCI7XG5jb25zdCBzd2lybE1ldGEgPSB7XG4gIG1heENvbG9yQ291bnQ6IDEwXG59O1xuY29uc3Qgc3dpcmxGcmFnbWVudFNoYWRlciA9IGAjdmVyc2lvbiAzMDAgZXNcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXG51bmlmb3JtIGZsb2F0IHVfdGltZTtcblxudW5pZm9ybSB2ZWM0IHVfY29sb3JCYWNrO1xudW5pZm9ybSB2ZWM0IHVfY29sb3JzWyR7c3dpcmxNZXRhLm1heENvbG9yQ291bnR9XTtcbnVuaWZvcm0gZmxvYXQgdV9jb2xvcnNDb3VudDtcbnVuaWZvcm0gZmxvYXQgdV9iYW5kQ291bnQ7XG51bmlmb3JtIGZsb2F0IHVfdHdpc3Q7XG51bmlmb3JtIGZsb2F0IHVfY2VudGVyO1xudW5pZm9ybSBmbG9hdCB1X3Byb3BvcnRpb247XG51bmlmb3JtIGZsb2F0IHVfc29mdG5lc3M7XG51bmlmb3JtIGZsb2F0IHVfbm9pc2U7XG51bmlmb3JtIGZsb2F0IHVfbm9pc2VGcmVxdWVuY3k7XG5cbiR7c2l6aW5nVmFyaWFibGVzRGVjbGFyYXRpb259XG5cbm91dCB2ZWM0IGZyYWdDb2xvcjtcblxuJHtkZWNsYXJlUEl9XG4ke3NpbXBsZXhOb2lzZX1cbiR7cm90YXRpb24yfVxuXG52b2lkIG1haW4oKSB7XG4gIHZlYzIgc2hhcGVfdXYgPSB2X29iamVjdFVWO1xuXG4gIGZsb2F0IGwgPSBsZW5ndGgoc2hhcGVfdXYpO1xuICBsID0gbWF4KDFlLTQsIGwpO1xuICBcbiAgZmxvYXQgdCA9IHVfdGltZTtcblxuICBmbG9hdCBhbmdsZSA9IGNlaWwodV9iYW5kQ291bnQpICogYXRhbihzaGFwZV91di55LCBzaGFwZV91di54KSArIHQ7XG4gIGZsb2F0IGFuZ2xlX25vcm0gPSBhbmdsZSAvIFRXT19QSTtcblxuICBmbG9hdCB0d2lzdCA9IDMuICogY2xhbXAodV90d2lzdCwgMC4sIDEuKTtcbiAgZmxvYXQgb2Zmc2V0ID0gcG93KGwsIC10d2lzdCkgKyBhbmdsZV9ub3JtO1xuXG4gIGZsb2F0IHNoYXBlID0gZnJhY3Qob2Zmc2V0KTtcbiAgc2hhcGUgPSAxLiAtIGFicygyLiAqIHNoYXBlIC0gMS4pO1xuICBzaGFwZSArPSB1X25vaXNlICogc25vaXNlKDE1LiAqIHBvdyh1X25vaXNlRnJlcXVlbmN5LCAyLikgKiBzaGFwZV91dik7XG5cbiAgZmxvYXQgbWlkID0gc21vb3Roc3RlcCguMiwgLjIgKyAuOCAqIHVfY2VudGVyLCBwb3cobCwgdHdpc3QpKTtcbiAgc2hhcGUgPSBtaXgoMC4sIHNoYXBlLCBtaWQpO1xuXG4gIGZsb2F0IHByb3BvcnRpb24gPSBjbGFtcCh1X3Byb3BvcnRpb24sIDAuLCAxLik7XG4gIGZsb2F0IGV4cG9uZW50ID0gbWl4KC4yNSwgMS4sIHByb3BvcnRpb24gKiAyLik7XG4gIGV4cG9uZW50ID0gbWl4KGV4cG9uZW50LCAxMC4sIG1heCgwLiwgcHJvcG9ydGlvbiAqIDIuIC0gMS4pKTtcbiAgc2hhcGUgPSBwb3coc2hhcGUsIGV4cG9uZW50KTtcblxuICBmbG9hdCBtaXhlciA9IHNoYXBlICogdV9jb2xvcnNDb3VudDtcbiAgdmVjNCBncmFkaWVudCA9IHVfY29sb3JzWzBdO1xuICBncmFkaWVudC5yZ2IgKj0gZ3JhZGllbnQuYTtcbiAgXG4gIGZsb2F0IG91dGVyU2hhcGUgPSAwLjtcbiAgZm9yIChpbnQgaSA9IDE7IGkgPCAke3N3aXJsTWV0YS5tYXhDb2xvckNvdW50ICsgMX07IGkrKykge1xuICAgIGlmIChpID4gaW50KHVfY29sb3JzQ291bnQpKSBicmVhaztcblxuICAgIGZsb2F0IG0gPSBjbGFtcChtaXhlciAtIGZsb2F0KGkgLSAxKSwgMC4sIDEuKTtcbiAgICBmbG9hdCBhYSA9IGZ3aWR0aChtKTtcbiAgICBtID0gc21vb3Roc3RlcCguNSAtIC41ICogdV9zb2Z0bmVzcyAtIGFhLCAuNSArIC41ICogdV9zb2Z0bmVzcyArIGFhLCBtKTtcblxuICAgIGlmIChpID09IDEpIHtcbiAgICAgIG91dGVyU2hhcGUgPSBtO1xuICAgIH1cblxuICAgIHZlYzQgYyA9IHVfY29sb3JzW2kgLSAxXTtcbiAgICBjLnJnYiAqPSBjLmE7XG4gICAgZ3JhZGllbnQgPSBtaXgoZ3JhZGllbnQsIGMsIG0pO1xuICB9XG5cbiAgZmxvYXQgbWlkQUEgPSAuMSAqIGZ3aWR0aChwb3cobCwgLXR3aXN0KSk7XG4gIGZsb2F0IG91dGVyTWlkID0gc21vb3Roc3RlcCguMiwgLjIgKyBtaWRBQSwgcG93KGwsIHR3aXN0KSk7XG4gIG91dGVyU2hhcGUgPSBtaXgoMC4sIG91dGVyU2hhcGUsIG91dGVyTWlkKTtcblxuICB2ZWMzIGNvbG9yID0gZ3JhZGllbnQucmdiICogb3V0ZXJTaGFwZTtcbiAgZmxvYXQgb3BhY2l0eSA9IGdyYWRpZW50LmEgKiBvdXRlclNoYXBlO1xuXG4gIHZlYzMgYmdDb2xvciA9IHVfY29sb3JCYWNrLnJnYiAqIHVfY29sb3JCYWNrLmE7XG4gIGNvbG9yID0gY29sb3IgKyBiZ0NvbG9yICogKDEuMCAtIG9wYWNpdHkpO1xuICBvcGFjaXR5ID0gb3BhY2l0eSArIHVfY29sb3JCYWNrLmEgKiAoMS4wIC0gb3BhY2l0eSk7XG5cbiAgJHtjb2xvckJhbmRpbmdGaXh9XG5cbiAgZnJhZ0NvbG9yID0gdmVjNChjb2xvciwgb3BhY2l0eSk7XG59XG5gO1xuZXhwb3J0IHtcbiAgc3dpcmxGcmFnbWVudFNoYWRlcixcbiAgc3dpcmxNZXRhXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3dpcmwuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/shaders/swirl.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/vertex-shader.js":
/*!******************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/vertex-shader.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   vertexShaderSource: () => (/* binding */ vertexShaderSource)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nconst vertexShaderSource = `#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec4 a_position;\n\nuniform vec2 u_resolution;\nuniform float u_pixelRatio;\nuniform float u_imageAspectRatio;\n\nuniform float u_originX;\nuniform float u_originY;\nuniform float u_worldWidth;\nuniform float u_worldHeight;\nuniform float u_fit;\n\nuniform float u_scale;\nuniform float u_rotation;\nuniform float u_offsetX;\nuniform float u_offsetY;\n\nuniform float u_pxSize;\n\nout vec2 v_objectUV;\nout vec2 v_objectBoxSize;\nout vec2 v_objectHelperBox;\n\nout vec2 v_responsiveUV;\nout vec2 v_responsiveBoxSize;\nout vec2 v_responsiveHelperBox;\nout vec2 v_responsiveBoxGivenSize;\n\nout vec2 v_patternUV;\nout vec2 v_patternBoxSize;\nout vec2 v_patternHelperBox;\n\nout vec2 v_imageUV;\n\n// #define ADD_HELPERS\n\nvec3 getBoxSize(float boxRatio, vec2 givenBoxSize) {\n  vec2 box = vec2(0.);\n  // fit = none\n  box.x = boxRatio * min(givenBoxSize.x / boxRatio, givenBoxSize.y);\n  float noFitBoxWidth = box.x;\n  if (u_fit == 1.) { // fit = contain\n    box.x = boxRatio * min(u_resolution.x / boxRatio, u_resolution.y);\n  } else if (u_fit == 2.) { // fit = cover\n    box.x = boxRatio * max(u_resolution.x / boxRatio, u_resolution.y);\n  }\n  box.y = box.x / boxRatio;\n  return vec3(box, noFitBoxWidth);\n}\n\nvoid main() {\n  gl_Position = a_position;\n\n  vec2 uv = gl_Position.xy * .5;\n  vec2 boxOrigin = vec2(.5 - u_originX, u_originY - .5);\n  vec2 givenBoxSize = vec2(u_worldWidth, u_worldHeight);\n  givenBoxSize = max(givenBoxSize, vec2(1.)) * u_pixelRatio;\n  float r = u_rotation * 3.14159265358979323846 / 180.;\n  mat2 graphicRotation = mat2(cos(r), sin(r), -sin(r), cos(r));\n  vec2 graphicOffset = vec2(-u_offsetX, u_offsetY);\n\n\n  // ===================================================\n  // Sizing api for graphic objects with fixed ratio\n  // (currently supports only ratio = 1)\n\n  float fixedRatio = 1.;\n  vec2 fixedRatioBoxGivenSize = vec2(\n  (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n  (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n\n  v_objectBoxSize = getBoxSize(fixedRatio, fixedRatioBoxGivenSize).xy;\n  vec2 objectWorldScale = u_resolution.xy / v_objectBoxSize;\n\n  #ifdef ADD_HELPERS\n  v_objectHelperBox = uv;\n  v_objectHelperBox *= objectWorldScale;\n  v_objectHelperBox += boxOrigin * (objectWorldScale - 1.);\n  #endif\n\n  v_objectUV = uv;\n  v_objectUV *= objectWorldScale;\n  v_objectUV += boxOrigin * (objectWorldScale - 1.);\n  v_objectUV += graphicOffset;\n  v_objectUV /= u_scale;\n  v_objectUV = graphicRotation * v_objectUV;\n\n\n  // ===================================================\n\n\n  // ===================================================\n  // Sizing api for graphic objects with either givenBoxSize ratio or canvas ratio.\n  // Full-screen mode available with u_worldWidth = u_worldHeight = 0\n\n  v_responsiveBoxGivenSize = vec2(\n  (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n  (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n  float responsiveRatio = v_responsiveBoxGivenSize.x / v_responsiveBoxGivenSize.y;\n  v_responsiveBoxSize = getBoxSize(responsiveRatio, v_responsiveBoxGivenSize).xy;\n  vec2 responsiveBoxScale = u_resolution.xy / v_responsiveBoxSize;\n\n  #ifdef ADD_HELPERS\n  v_responsiveHelperBox = uv;\n  v_responsiveHelperBox *= responsiveBoxScale;\n  v_responsiveHelperBox += boxOrigin * (responsiveBoxScale - 1.);\n  #endif\n\n  v_responsiveUV = uv;\n  v_responsiveUV *= responsiveBoxScale;\n  v_responsiveUV += boxOrigin * (responsiveBoxScale - 1.);\n  v_responsiveUV += graphicOffset;\n  v_responsiveUV /= u_scale;\n  v_responsiveUV.x *= responsiveRatio;\n  v_responsiveUV = graphicRotation * v_responsiveUV;\n  v_responsiveUV.x /= responsiveRatio;\n\n  // ===================================================\n\n\n  // ===================================================\n  // Sizing api for patterns\n  // (treating graphics as a image u_worldWidth x u_worldHeight size)\n\n  float patternBoxRatio = givenBoxSize.x / givenBoxSize.y;\n  vec2 patternBoxGivenSize = vec2(\n  (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n  (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n  patternBoxRatio = patternBoxGivenSize.x / patternBoxGivenSize.y;\n\n  vec3 boxSizeData = getBoxSize(patternBoxRatio, patternBoxGivenSize);\n  v_patternBoxSize = boxSizeData.xy;\n  float patternBoxNoFitBoxWidth = boxSizeData.z;\n  vec2 patternBoxScale = u_resolution.xy / v_patternBoxSize;\n\n  #ifdef ADD_HELPERS\n  v_patternHelperBox = uv;\n  v_patternHelperBox *= patternBoxScale;\n  v_patternHelperBox += boxOrigin * (patternBoxScale - 1.);\n  #endif\n\n  v_patternUV = uv;\n  v_patternUV += graphicOffset / patternBoxScale;\n  v_patternUV += boxOrigin;\n  v_patternUV -= boxOrigin / patternBoxScale;\n  v_patternUV *= u_resolution.xy;\n  v_patternUV /= u_pixelRatio;\n  if (u_fit > 0.) {\n    v_patternUV *= (patternBoxNoFitBoxWidth / v_patternBoxSize.x);\n  }\n  v_patternUV /= u_scale;\n  v_patternUV = graphicRotation * v_patternUV;\n  v_patternUV += boxOrigin / patternBoxScale;\n  v_patternUV -= boxOrigin;\n  // x100 is a default multiplier between vertex and fragmant shaders\n  // we use it to avoid UV presision issues\n  v_patternUV *= .01;\n\n  // ===================================================\n\n\n  // ===================================================\n  // Sizing api for images\n\n  vec2 imageBoxSize;\n  if (u_fit == 1.) { // contain\n    imageBoxSize.x = min(u_resolution.x / u_imageAspectRatio, u_resolution.y) * u_imageAspectRatio;\n  } else if (u_fit == 2.) { // cover\n    imageBoxSize.x = max(u_resolution.x / u_imageAspectRatio, u_resolution.y) * u_imageAspectRatio;\n  } else {\n    imageBoxSize.x = min(10.0, 10.0 / u_imageAspectRatio * u_imageAspectRatio);\n  }\n  imageBoxSize.y = imageBoxSize.x / u_imageAspectRatio;\n  vec2 imageBoxScale = u_resolution.xy / imageBoxSize;\n\n  #ifdef ADD_HELPERS\n  vec2 imageHelperBox = uv;\n  imageHelperBox *= imageBoxScale;\n  imageHelperBox += boxOrigin * (imageBoxScale - 1.);\n  #endif\n\n  v_imageUV = uv;\n  v_imageUV *= imageBoxScale;\n  v_imageUV += boxOrigin * (imageBoxScale - 1.);\n  v_imageUV += graphicOffset;\n  v_imageUV /= u_scale;\n  v_imageUV.x *= u_imageAspectRatio;\n  v_imageUV = graphicRotation * v_imageUV;\n  v_imageUV.x /= u_imageAspectRatio;\n\n  v_imageUV += .5;\n  v_imageUV.y = 1. - v_imageUV.y;\n\n  // ===================================================\n\n}`;\n\n//# sourceMappingURL=vertex-shader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3QvdmVydGV4LXNoYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxJQUFJLHdCQUF3QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxJQUFJLHdCQUF3QjtBQUM1QjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxDQUFDO0FBR0M7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2FydHRpY2ZveC9EZXNrdG9wL1dvcmsvcGhvdG9hcHAvbm9kZV9tb2R1bGVzL0BwYXBlci1kZXNpZ24vc2hhZGVycy9kaXN0L3ZlcnRleC1zaGFkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqICAgICAgICAgICAgICAgICAgICBQYXBlciBTaGFkZXJzICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICBodHRwczovL2dpdGh1Yi5jb20vcGFwZXItZGVzaWduL3NoYWRlcnMgICAgICAgKlxuICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICovXG5cbmNvbnN0IHZlcnRleFNoYWRlclNvdXJjZSA9IGAjdmVyc2lvbiAzMDAgZXNcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXG5sYXlvdXQobG9jYXRpb24gPSAwKSBpbiB2ZWM0IGFfcG9zaXRpb247XG5cbnVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247XG51bmlmb3JtIGZsb2F0IHVfcGl4ZWxSYXRpbztcbnVuaWZvcm0gZmxvYXQgdV9pbWFnZUFzcGVjdFJhdGlvO1xuXG51bmlmb3JtIGZsb2F0IHVfb3JpZ2luWDtcbnVuaWZvcm0gZmxvYXQgdV9vcmlnaW5ZO1xudW5pZm9ybSBmbG9hdCB1X3dvcmxkV2lkdGg7XG51bmlmb3JtIGZsb2F0IHVfd29ybGRIZWlnaHQ7XG51bmlmb3JtIGZsb2F0IHVfZml0O1xuXG51bmlmb3JtIGZsb2F0IHVfc2NhbGU7XG51bmlmb3JtIGZsb2F0IHVfcm90YXRpb247XG51bmlmb3JtIGZsb2F0IHVfb2Zmc2V0WDtcbnVuaWZvcm0gZmxvYXQgdV9vZmZzZXRZO1xuXG51bmlmb3JtIGZsb2F0IHVfcHhTaXplO1xuXG5vdXQgdmVjMiB2X29iamVjdFVWO1xub3V0IHZlYzIgdl9vYmplY3RCb3hTaXplO1xub3V0IHZlYzIgdl9vYmplY3RIZWxwZXJCb3g7XG5cbm91dCB2ZWMyIHZfcmVzcG9uc2l2ZVVWO1xub3V0IHZlYzIgdl9yZXNwb25zaXZlQm94U2l6ZTtcbm91dCB2ZWMyIHZfcmVzcG9uc2l2ZUhlbHBlckJveDtcbm91dCB2ZWMyIHZfcmVzcG9uc2l2ZUJveEdpdmVuU2l6ZTtcblxub3V0IHZlYzIgdl9wYXR0ZXJuVVY7XG5vdXQgdmVjMiB2X3BhdHRlcm5Cb3hTaXplO1xub3V0IHZlYzIgdl9wYXR0ZXJuSGVscGVyQm94O1xuXG5vdXQgdmVjMiB2X2ltYWdlVVY7XG5cbi8vICNkZWZpbmUgQUREX0hFTFBFUlNcblxudmVjMyBnZXRCb3hTaXplKGZsb2F0IGJveFJhdGlvLCB2ZWMyIGdpdmVuQm94U2l6ZSkge1xuICB2ZWMyIGJveCA9IHZlYzIoMC4pO1xuICAvLyBmaXQgPSBub25lXG4gIGJveC54ID0gYm94UmF0aW8gKiBtaW4oZ2l2ZW5Cb3hTaXplLnggLyBib3hSYXRpbywgZ2l2ZW5Cb3hTaXplLnkpO1xuICBmbG9hdCBub0ZpdEJveFdpZHRoID0gYm94Lng7XG4gIGlmICh1X2ZpdCA9PSAxLikgeyAvLyBmaXQgPSBjb250YWluXG4gICAgYm94LnggPSBib3hSYXRpbyAqIG1pbih1X3Jlc29sdXRpb24ueCAvIGJveFJhdGlvLCB1X3Jlc29sdXRpb24ueSk7XG4gIH0gZWxzZSBpZiAodV9maXQgPT0gMi4pIHsgLy8gZml0ID0gY292ZXJcbiAgICBib3gueCA9IGJveFJhdGlvICogbWF4KHVfcmVzb2x1dGlvbi54IC8gYm94UmF0aW8sIHVfcmVzb2x1dGlvbi55KTtcbiAgfVxuICBib3gueSA9IGJveC54IC8gYm94UmF0aW87XG4gIHJldHVybiB2ZWMzKGJveCwgbm9GaXRCb3hXaWR0aCk7XG59XG5cbnZvaWQgbWFpbigpIHtcbiAgZ2xfUG9zaXRpb24gPSBhX3Bvc2l0aW9uO1xuXG4gIHZlYzIgdXYgPSBnbF9Qb3NpdGlvbi54eSAqIC41O1xuICB2ZWMyIGJveE9yaWdpbiA9IHZlYzIoLjUgLSB1X29yaWdpblgsIHVfb3JpZ2luWSAtIC41KTtcbiAgdmVjMiBnaXZlbkJveFNpemUgPSB2ZWMyKHVfd29ybGRXaWR0aCwgdV93b3JsZEhlaWdodCk7XG4gIGdpdmVuQm94U2l6ZSA9IG1heChnaXZlbkJveFNpemUsIHZlYzIoMS4pKSAqIHVfcGl4ZWxSYXRpbztcbiAgZmxvYXQgciA9IHVfcm90YXRpb24gKiAzLjE0MTU5MjY1MzU4OTc5MzIzODQ2IC8gMTgwLjtcbiAgbWF0MiBncmFwaGljUm90YXRpb24gPSBtYXQyKGNvcyhyKSwgc2luKHIpLCAtc2luKHIpLCBjb3MocikpO1xuICB2ZWMyIGdyYXBoaWNPZmZzZXQgPSB2ZWMyKC11X29mZnNldFgsIHVfb2Zmc2V0WSk7XG5cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gU2l6aW5nIGFwaSBmb3IgZ3JhcGhpYyBvYmplY3RzIHdpdGggZml4ZWQgcmF0aW9cbiAgLy8gKGN1cnJlbnRseSBzdXBwb3J0cyBvbmx5IHJhdGlvID0gMSlcblxuICBmbG9hdCBmaXhlZFJhdGlvID0gMS47XG4gIHZlYzIgZml4ZWRSYXRpb0JveEdpdmVuU2l6ZSA9IHZlYzIoXG4gICh1X3dvcmxkV2lkdGggPT0gMC4pID8gdV9yZXNvbHV0aW9uLnggOiBnaXZlbkJveFNpemUueCxcbiAgKHVfd29ybGRIZWlnaHQgPT0gMC4pID8gdV9yZXNvbHV0aW9uLnkgOiBnaXZlbkJveFNpemUueVxuICApO1xuXG4gIHZfb2JqZWN0Qm94U2l6ZSA9IGdldEJveFNpemUoZml4ZWRSYXRpbywgZml4ZWRSYXRpb0JveEdpdmVuU2l6ZSkueHk7XG4gIHZlYzIgb2JqZWN0V29ybGRTY2FsZSA9IHVfcmVzb2x1dGlvbi54eSAvIHZfb2JqZWN0Qm94U2l6ZTtcblxuICAjaWZkZWYgQUREX0hFTFBFUlNcbiAgdl9vYmplY3RIZWxwZXJCb3ggPSB1djtcbiAgdl9vYmplY3RIZWxwZXJCb3ggKj0gb2JqZWN0V29ybGRTY2FsZTtcbiAgdl9vYmplY3RIZWxwZXJCb3ggKz0gYm94T3JpZ2luICogKG9iamVjdFdvcmxkU2NhbGUgLSAxLik7XG4gICNlbmRpZlxuXG4gIHZfb2JqZWN0VVYgPSB1djtcbiAgdl9vYmplY3RVViAqPSBvYmplY3RXb3JsZFNjYWxlO1xuICB2X29iamVjdFVWICs9IGJveE9yaWdpbiAqIChvYmplY3RXb3JsZFNjYWxlIC0gMS4pO1xuICB2X29iamVjdFVWICs9IGdyYXBoaWNPZmZzZXQ7XG4gIHZfb2JqZWN0VVYgLz0gdV9zY2FsZTtcbiAgdl9vYmplY3RVViA9IGdyYXBoaWNSb3RhdGlvbiAqIHZfb2JqZWN0VVY7XG5cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBTaXppbmcgYXBpIGZvciBncmFwaGljIG9iamVjdHMgd2l0aCBlaXRoZXIgZ2l2ZW5Cb3hTaXplIHJhdGlvIG9yIGNhbnZhcyByYXRpby5cbiAgLy8gRnVsbC1zY3JlZW4gbW9kZSBhdmFpbGFibGUgd2l0aCB1X3dvcmxkV2lkdGggPSB1X3dvcmxkSGVpZ2h0ID0gMFxuXG4gIHZfcmVzcG9uc2l2ZUJveEdpdmVuU2l6ZSA9IHZlYzIoXG4gICh1X3dvcmxkV2lkdGggPT0gMC4pID8gdV9yZXNvbHV0aW9uLnggOiBnaXZlbkJveFNpemUueCxcbiAgKHVfd29ybGRIZWlnaHQgPT0gMC4pID8gdV9yZXNvbHV0aW9uLnkgOiBnaXZlbkJveFNpemUueVxuICApO1xuICBmbG9hdCByZXNwb25zaXZlUmF0aW8gPSB2X3Jlc3BvbnNpdmVCb3hHaXZlblNpemUueCAvIHZfcmVzcG9uc2l2ZUJveEdpdmVuU2l6ZS55O1xuICB2X3Jlc3BvbnNpdmVCb3hTaXplID0gZ2V0Qm94U2l6ZShyZXNwb25zaXZlUmF0aW8sIHZfcmVzcG9uc2l2ZUJveEdpdmVuU2l6ZSkueHk7XG4gIHZlYzIgcmVzcG9uc2l2ZUJveFNjYWxlID0gdV9yZXNvbHV0aW9uLnh5IC8gdl9yZXNwb25zaXZlQm94U2l6ZTtcblxuICAjaWZkZWYgQUREX0hFTFBFUlNcbiAgdl9yZXNwb25zaXZlSGVscGVyQm94ID0gdXY7XG4gIHZfcmVzcG9uc2l2ZUhlbHBlckJveCAqPSByZXNwb25zaXZlQm94U2NhbGU7XG4gIHZfcmVzcG9uc2l2ZUhlbHBlckJveCArPSBib3hPcmlnaW4gKiAocmVzcG9uc2l2ZUJveFNjYWxlIC0gMS4pO1xuICAjZW5kaWZcblxuICB2X3Jlc3BvbnNpdmVVViA9IHV2O1xuICB2X3Jlc3BvbnNpdmVVViAqPSByZXNwb25zaXZlQm94U2NhbGU7XG4gIHZfcmVzcG9uc2l2ZVVWICs9IGJveE9yaWdpbiAqIChyZXNwb25zaXZlQm94U2NhbGUgLSAxLik7XG4gIHZfcmVzcG9uc2l2ZVVWICs9IGdyYXBoaWNPZmZzZXQ7XG4gIHZfcmVzcG9uc2l2ZVVWIC89IHVfc2NhbGU7XG4gIHZfcmVzcG9uc2l2ZVVWLnggKj0gcmVzcG9uc2l2ZVJhdGlvO1xuICB2X3Jlc3BvbnNpdmVVViA9IGdyYXBoaWNSb3RhdGlvbiAqIHZfcmVzcG9uc2l2ZVVWO1xuICB2X3Jlc3BvbnNpdmVVVi54IC89IHJlc3BvbnNpdmVSYXRpbztcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBTaXppbmcgYXBpIGZvciBwYXR0ZXJuc1xuICAvLyAodHJlYXRpbmcgZ3JhcGhpY3MgYXMgYSBpbWFnZSB1X3dvcmxkV2lkdGggeCB1X3dvcmxkSGVpZ2h0IHNpemUpXG5cbiAgZmxvYXQgcGF0dGVybkJveFJhdGlvID0gZ2l2ZW5Cb3hTaXplLnggLyBnaXZlbkJveFNpemUueTtcbiAgdmVjMiBwYXR0ZXJuQm94R2l2ZW5TaXplID0gdmVjMihcbiAgKHVfd29ybGRXaWR0aCA9PSAwLikgPyB1X3Jlc29sdXRpb24ueCA6IGdpdmVuQm94U2l6ZS54LFxuICAodV93b3JsZEhlaWdodCA9PSAwLikgPyB1X3Jlc29sdXRpb24ueSA6IGdpdmVuQm94U2l6ZS55XG4gICk7XG4gIHBhdHRlcm5Cb3hSYXRpbyA9IHBhdHRlcm5Cb3hHaXZlblNpemUueCAvIHBhdHRlcm5Cb3hHaXZlblNpemUueTtcblxuICB2ZWMzIGJveFNpemVEYXRhID0gZ2V0Qm94U2l6ZShwYXR0ZXJuQm94UmF0aW8sIHBhdHRlcm5Cb3hHaXZlblNpemUpO1xuICB2X3BhdHRlcm5Cb3hTaXplID0gYm94U2l6ZURhdGEueHk7XG4gIGZsb2F0IHBhdHRlcm5Cb3hOb0ZpdEJveFdpZHRoID0gYm94U2l6ZURhdGEuejtcbiAgdmVjMiBwYXR0ZXJuQm94U2NhbGUgPSB1X3Jlc29sdXRpb24ueHkgLyB2X3BhdHRlcm5Cb3hTaXplO1xuXG4gICNpZmRlZiBBRERfSEVMUEVSU1xuICB2X3BhdHRlcm5IZWxwZXJCb3ggPSB1djtcbiAgdl9wYXR0ZXJuSGVscGVyQm94ICo9IHBhdHRlcm5Cb3hTY2FsZTtcbiAgdl9wYXR0ZXJuSGVscGVyQm94ICs9IGJveE9yaWdpbiAqIChwYXR0ZXJuQm94U2NhbGUgLSAxLik7XG4gICNlbmRpZlxuXG4gIHZfcGF0dGVyblVWID0gdXY7XG4gIHZfcGF0dGVyblVWICs9IGdyYXBoaWNPZmZzZXQgLyBwYXR0ZXJuQm94U2NhbGU7XG4gIHZfcGF0dGVyblVWICs9IGJveE9yaWdpbjtcbiAgdl9wYXR0ZXJuVVYgLT0gYm94T3JpZ2luIC8gcGF0dGVybkJveFNjYWxlO1xuICB2X3BhdHRlcm5VViAqPSB1X3Jlc29sdXRpb24ueHk7XG4gIHZfcGF0dGVyblVWIC89IHVfcGl4ZWxSYXRpbztcbiAgaWYgKHVfZml0ID4gMC4pIHtcbiAgICB2X3BhdHRlcm5VViAqPSAocGF0dGVybkJveE5vRml0Qm94V2lkdGggLyB2X3BhdHRlcm5Cb3hTaXplLngpO1xuICB9XG4gIHZfcGF0dGVyblVWIC89IHVfc2NhbGU7XG4gIHZfcGF0dGVyblVWID0gZ3JhcGhpY1JvdGF0aW9uICogdl9wYXR0ZXJuVVY7XG4gIHZfcGF0dGVyblVWICs9IGJveE9yaWdpbiAvIHBhdHRlcm5Cb3hTY2FsZTtcbiAgdl9wYXR0ZXJuVVYgLT0gYm94T3JpZ2luO1xuICAvLyB4MTAwIGlzIGEgZGVmYXVsdCBtdWx0aXBsaWVyIGJldHdlZW4gdmVydGV4IGFuZCBmcmFnbWFudCBzaGFkZXJzXG4gIC8vIHdlIHVzZSBpdCB0byBhdm9pZCBVViBwcmVzaXNpb24gaXNzdWVzXG4gIHZfcGF0dGVyblVWICo9IC4wMTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBTaXppbmcgYXBpIGZvciBpbWFnZXNcblxuICB2ZWMyIGltYWdlQm94U2l6ZTtcbiAgaWYgKHVfZml0ID09IDEuKSB7IC8vIGNvbnRhaW5cbiAgICBpbWFnZUJveFNpemUueCA9IG1pbih1X3Jlc29sdXRpb24ueCAvIHVfaW1hZ2VBc3BlY3RSYXRpbywgdV9yZXNvbHV0aW9uLnkpICogdV9pbWFnZUFzcGVjdFJhdGlvO1xuICB9IGVsc2UgaWYgKHVfZml0ID09IDIuKSB7IC8vIGNvdmVyXG4gICAgaW1hZ2VCb3hTaXplLnggPSBtYXgodV9yZXNvbHV0aW9uLnggLyB1X2ltYWdlQXNwZWN0UmF0aW8sIHVfcmVzb2x1dGlvbi55KSAqIHVfaW1hZ2VBc3BlY3RSYXRpbztcbiAgfSBlbHNlIHtcbiAgICBpbWFnZUJveFNpemUueCA9IG1pbigxMC4wLCAxMC4wIC8gdV9pbWFnZUFzcGVjdFJhdGlvICogdV9pbWFnZUFzcGVjdFJhdGlvKTtcbiAgfVxuICBpbWFnZUJveFNpemUueSA9IGltYWdlQm94U2l6ZS54IC8gdV9pbWFnZUFzcGVjdFJhdGlvO1xuICB2ZWMyIGltYWdlQm94U2NhbGUgPSB1X3Jlc29sdXRpb24ueHkgLyBpbWFnZUJveFNpemU7XG5cbiAgI2lmZGVmIEFERF9IRUxQRVJTXG4gIHZlYzIgaW1hZ2VIZWxwZXJCb3ggPSB1djtcbiAgaW1hZ2VIZWxwZXJCb3ggKj0gaW1hZ2VCb3hTY2FsZTtcbiAgaW1hZ2VIZWxwZXJCb3ggKz0gYm94T3JpZ2luICogKGltYWdlQm94U2NhbGUgLSAxLik7XG4gICNlbmRpZlxuXG4gIHZfaW1hZ2VVViA9IHV2O1xuICB2X2ltYWdlVVYgKj0gaW1hZ2VCb3hTY2FsZTtcbiAgdl9pbWFnZVVWICs9IGJveE9yaWdpbiAqIChpbWFnZUJveFNjYWxlIC0gMS4pO1xuICB2X2ltYWdlVVYgKz0gZ3JhcGhpY09mZnNldDtcbiAgdl9pbWFnZVVWIC89IHVfc2NhbGU7XG4gIHZfaW1hZ2VVVi54ICo9IHVfaW1hZ2VBc3BlY3RSYXRpbztcbiAgdl9pbWFnZVVWID0gZ3JhcGhpY1JvdGF0aW9uICogdl9pbWFnZVVWO1xuICB2X2ltYWdlVVYueCAvPSB1X2ltYWdlQXNwZWN0UmF0aW87XG5cbiAgdl9pbWFnZVVWICs9IC41O1xuICB2X2ltYWdlVVYueSA9IDEuIC0gdl9pbWFnZVVWLnk7XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbn1gO1xuZXhwb3J0IHtcbiAgdmVydGV4U2hhZGVyU291cmNlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVydGV4LXNoYWRlci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/vertex-shader.js\n");

/***/ })

};
;